{
  "openapi": "3.0.2",
  "info": {
    "title": "Coiote IoT Device Management Rest API",
    "version": "3.6.0"
  },
  "paths": {
    "/assignedDeviceProperties": {
      "get": {
        "tags": [
          "AssignedDeviceProperties"
        ],
        "description": "\n ## Overview\n Get AssignedDeviceProperties entities using search criteria.\n ## Additional information\n To retrieve an AssignedDeviceProperty, it has to be created first.\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n<br>\n To get all assigned device properties **do not use any criteria**.\n <br>\n To get assigned device properties with _externalId_ 'example', use:\n\n\n ```\n externalId eq 'example'\n ```\n\n <br>\n\n To get assigned device properties with _lastMatchedDevice_ that starts with 'example', use:\n\n\n ```\n lastMatchedDevice startswith 'example'\n ```\n\n <br>\n\n To get combined search criteria, use:\n\n\n ```\n externalId eq 'example', lastMatchedDevice startswith 'example'\n ```\n",
        "operationId": "assignedDeviceProperties_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **externalId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **target** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **lastMatchedDevice** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AssignedPropertiesQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ExternalId"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/assignedDeviceProperties/{externalId}": {
      "get": {
        "tags": [
          "AssignedDeviceProperties"
        ],
        "description": "\n ## Overview\n Get information about a single instance of AssignedDeviceProperties.\n ## Additional information\n      You must provide assigned device property ID as the path parameter `externalId`.\n",
        "operationId": "assignedDeviceProperties_get",
        "parameters": [
          {
            "name": "externalId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssignedPropertiesGet"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "AssignedDeviceProperties"
        ],
        "description": "\n ## Overview\n Create or overwrite single instance of AssignedDeviceProperties information.\n ## Additional information\n      You must provide assigned device property ID as the path parameter `externalId`.\n If AssignedDeviceProperty with given externalId already exists then it will be completely overwritten and its state will be restarted.\n Provided externalId is an arbitrary, not empty string used later for referring to this AssignedDeviceProperties.\n Configured properties will be set as device properties on devices that are matched by target parameter.\n Device is matched when it has device property with name target.key and value target.value. The possible values of target.key are defined in Coiote-DM configuration.\n When multiShot is set to false properties will be set only once only on first matched device.\n <br>\n **Note:** The properties are set on device only when applyAssignedProperties tag is executed in XmlTask on device. Such task is not added by default.\n ## Usage example\n To add external identity to target devices provide the path parameter `externalId` and use the following request body:\n\n <br>\n\n ```\n {\n  \"target\": {\n    \"key\": \"assignmentId\",\n    \"value\": \"assignmentIdValue\"\n  },\n  \"isActive\": true,\n  \"properties\": {\n    \"propertyKey\": \"propertyValue\"\n  },\n  \"multiShot\": true\n}\n```\n",
        "operationId": "assignedDeviceProperties_createUpdate",
        "parameters": [
          {
            "name": "externalId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssignedPropertiesPut"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "AssignedDeviceProperties"
        ],
        "description": "\n ## Overview\n Delete AssignedDeviceProperties instance with a given externalId.\n ## Additional information\n      You must provide assigned device property ID as the path parameter `externalId`.\n When reapply is set to true the AssignedDeviceProperties will be applied again even if multiShot is set to false.\n",
        "operationId": "assignedDeviceProperties_delete",
        "parameters": [
          {
            "name": "externalId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "AssignedDeviceProperties"
        ],
        "description": "\n ## Overview\n Modify selected AssignedDeviceProperties parameters without affecting the rest of them.\n ## Additional information\n      You must provide assigned device property ID as the path parameter `externalId`.\n When reapply is set to true, the AssignedDeviceProperties will be applied again, even if multiShot is set to false.\n\n ## Usage example\n To add external identity to target devices provide the path parameter `externalId` and use the following body:\n\n <br>\n\n ```\n{\n  \"isActive\": true,\n  \"putProperties\": {\n    \"propertyKey\": \"propertyValue\"\n  },\n  \"removeProperties\": [\n    \"propertyToRemove\"\n  ],\n  \"multiShot\": true,\n  \"reapply\": false\n}\n```\n",
        "operationId": "assignedDeviceProperties_patch",
        "parameters": [
          {
            "name": "externalId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssignedPropertiesPatch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssignedPropertiesGet"
                }
              }
            }
          }
        }
      }
    },
    "/auth/certificates": {
      "post": {
        "tags": [
          "CertificatesAuth"
        ],
        "description": "\n ## Overview\n Save the certificate for validating incoming requests.\n ## Additional information\n      You must provide certificate in PEM format.\n There can be only one certificate per domain.\n ## Usage example\n Prepare certificate in PEM format and use it in the request body, for example:\n\n <br>\n\n ```\n {\n \"certificatePem\": \"-----BEGIN CERTIFICATE-----\n Wm7DCfrPNGVwFWUQOmsPue9rZBgO\n <...>\n-----END CERTIFICATE-----\"\n}\n",
        "operationId": "auth_saveUserAuthCert",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserAuthCertRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      },
      "delete": {
        "tags": [
          "CertificatesAuth"
        ],
        "description": "\n ## Overview\n Delete the certificate for validating incoming requests.\n ## Additional information\n There can be only one certificate per domain. The request deletes the certificate from the user domain.\n",
        "operationId": "auth_deleteUserAuthCert",
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      }
    },
    "/awsIntegration/auth/externalCertificate": {
      "post": {
        "tags": [
          "AwsIntegration"
        ],
        "description": "\n ## Overview\n Save the certificate used by AWS for integration with the platform.\n This certificate is assigned to the user domain.\n ## Additional information\n Both certificate and private key must be in PEM format. Only one certificate per domain is allowed.\n ## Usage example\n Prepare certificate and private key in PEM format and include them in the request body:\n\n <br>\n\n ```\n{\n \"certificatePem\": \"-----BEGIN CERTIFICATE-----\n Wm7DCfrPNGVwFWUQOmsPue9rZBgO\n <...>\n-----END CERTIFICATE-----\",\n \"privateKey\": \"-----BEGIN RSA PRIVATE KEY-----\n MIIBOgIBAAJBAKj34GkxFhD90vcN\n <...>\n-----END RSA PRIVATE KEY-----\"\n}\n",
        "operationId": "awsIntegration_auth_saveAwsExternalCertificate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AwsExternalCertificateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      },
      "delete": {
        "tags": [
          "AwsIntegration"
        ],
        "description": "\n ## Overview\n Delete the certificate used by AWS for integration with the platform.\n ## Additional information\n Only one certificate per domain is allowed. The request deletes the certificate from the user domain.\n",
        "operationId": "awsIntegration_auth_deleteAwsExternalCertificate",
        "responses": {
          "204": {
            "description": "Success"
          }
        }
      }
    },
    "/cachedDataModels/{deviceId}": {
      "get": {
        "tags": [
          "CachedDataModels"
        ],
        "description": "\n ## Overview\n Get the device data model or selected values for device data model parameters given in a query parameter.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n You can specify data model paths that you want to have returned as an array in a query parameter.\n Data model paths should be dot-separated.\n If parameters list is empty then the complete data model is returned.\n Query for all sub-parameters of given object should end with \".\". For example: \"Location.\".\n ## Usage example\n Provide device identity as `deviceId` and include the query parameter \"Temperature.0.Sensor Value\" to get the value of a selected data model parameter: temperature sensor.  \n",
        "operationId": "cachedDataModels_getParameters",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "parameters",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DataModelParameter"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler": {
      "get": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Listen to all event handlers configured for your domain. Use the `domain` query parameter to specify\n the domain, otherwise the domain of user authorizing the request will be selected.\n\n ## Additional information\n Possible custom error codes in the response body:\n\n **4041**: The domain with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n ",
        "operationId": "deviceEvents_handlers_getHandlers",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DeviceEventsHandler"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/kafka": {
      "post": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Create an event handler that forwards events to a publicly accessible Kafka instance.\n Use the `domain` query parameter to specify\n the domain, otherwise the domain of user authorizing the request will be selected.\n\n ## Additional information\n\n ### 1. Configuring the connection to the Kafka instance\n\n There are two ways to specify the connection config to the target Kafka instance:\n\n - **Use Kafka domain properties** - if your domain has Kafka properties configured, you can re-use them in this handler.\n Whenever the configuration changes, it will be reflected in your event handler. This can be achieved by setting the\n `connectionConfig.type` field to `\"domainProperties\"` in the request body.\n\n - **Use custom Kafka producer configuration** - you can specify the Kafka configuration directly in the request body.\n This configuration must follow `.properties` file format syntax and contain at least the addresses for\n bootstrap servers of your Kafka cluster.\n **Note:** If your config contains \"sasl.jaas.config\" property, it is advised\n to wrap the \"username\" and \"password\" fields with `\\\"` characters - see example in the section **Usage example**.\n\n\n In both types of configuration, for security reasons, the following parameters will be appended to the producer configuration:\n </br></br>\n ```\n retries = 0\n max.block.ms = 8000\n ```\n\n\n ### 2. Selecting forwarded events by applying filter\n\n \n Each handler can forward events of only one of two types:\n\n - **Telemetry** events - emitted each time a change in device's data is spotted by the system.\n\n - **Device** events - emitted each time device's state in the system changes.\n\n **Telemetry** events are usually emitted when the device sends a LwM2M Notify message to the server, device sends LwM2M Send message to the server,\n or the server carries out Read on device resource. For handlers that forward `telemetry` data, you can state for which LwM2M objects and resources\n the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition.\n\n </br>\n For example, the following filter allows all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303):\n </br> </br>\n\n ```\n \"filter\": {\n  \"type\": \"telemetry\",\n  \"lwm2mUrls\": [ \"/6/0/0\", \"/3303\" ]\n }\n ```\n\n </br> </br>\n\n **Device** events are emitted when one of the following takes place:\n\n - `deviceCreated` - when a device is added to the system,\n - `deviceFirstRegistration` - when a device connects for the first time,\n - `deviceUpdatedViaWrite` - when server carries out a Write to a device's resource,\n - `deviceUpdatedViaFota` - when server finishes execution of Firmware Upgrade (FOTA) on a device,\n - `deviceDeleted` - when a device is deleted from the system,\n \n </br>\n For example, the following filter allows events when device registers or carries out FOTA:\n </br> </br>\n\n ```\n \"filter\": {\n  \"type\": \"lifecycle\",\n  \"eventTypes\": [ \"deviceFirstRegistration\", \"deviceUpdatedViaFota\" ]\n }\n ```\n\n\n </br> </br>\n\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4002**: Kafka custom config is invalid. If your config contains 'sasl.jaas.config', wrap the 'username' and 'password' fields using a backslash and double quote character on each side.\n\n **4003**: Kafka domain property is not configured for this domain.\n\n **4004**: The available handlers limit has been reached.\n\n **4006**: The provided bootstrap server(s) is invalid or forbidden.\n\n **4041**: The domain with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n\n\n ## Usage example\n\n Prepare your Kafka producer configuration and an appropriate event filter and use them in the request body. The following example\n creates a handler from custom Kafka properties:\n </br> </br>\n ```\n {\n    \"type\": \"kafka\",\n    \"name\": \"Custom Kafka event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"type\": \"custom\",\n      \"value\": \"bootstrap.servers=kafka-cloud.com:9093\\nsecurity.protocol=SASL_PLAINTEXT\\nsasl.mechanism=SCRAM-SHA-256\\nsasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=\\\"kafka-user\\\" password=\\\"pass\\\";\",\n      \"topic\": \"iot.deviceEvents\",\n      \"headers\": {\n        \"Origin\": \"IoT DM\"\n      }\n    },\n    \"filter\": {\n      \"type\": \"lifecycle\",\n      \"eventTypes\": [ \"deviceCreated\" ]\n    },\n    \"description\": \"This handler forwards data to kafka-cloud.com\"\n }\n ```\n </br> </br>\n The following example creates a handler from Kafka config stored in domain properties:\n </br> </br>\n ```\n {\n    \"type\": \"kafka\",\n    \"name\": \"Domain Kafka event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"type\": \"domainProperty\",\n      \"topic\": \"coiote.deviceEvents\",\n      \"headers\": {\n        \"Origin\": \"IoT-DM\"\n      }\n    },\n    \"filter\": {\n      \"type\": \"lifecycle\",\n      \"eventTypes\": [ \"deviceCreated\" ]\n    },\n    \"description\": \"This handler forwards data to kafka-cloud.com\"\n }\n ```\n </br> </br>\n ",
        "operationId": "deviceEvents_handlers_createKafkaEventHandler",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceKafkaEventsHandlerCreateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HandlerId"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/kafka/{id}": {
      "put": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Update an event handler that forwards events to a publicly accessible Kafka instance.\n\n ## Additional information\n You must provide the handler ID as `id`.\n For information about the request body, see the description of POST /deviceEvents/handler/kafka.\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4002**: Kafka custom config is invalid. If your config contains 'sasl.jaas.config', wrap the 'username' and 'password' fields using a backslash and double quote character on each side.\n\n **4003**: Kafka domain property is not configured for this domain.\n\n **4006**: The provided bootstrap server(s) is invalid or forbidden.\n\n **5030**: System encountered error while processing request, please try again later.\n ",
        "operationId": "deviceEvents_handlers_updateKafkaEventHandler",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/HandlerId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceKafkaEventsHandlerUpdateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceEventsHandler"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/test/existing/{id}": {
      "post": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Test whether an event handler works. Request body will be generated automatically, based on the\n **filter** field of the handler configuration. If the event handler was previously disabled due to consecutive\n failures, testing it with successful result will cause it to be re-enabled by the system.\n\n ## Additional information\n Possible custom error codes in the response body:\n\n **4001**: Handler id must be a 24-byte hexadecimal string representation.\n\n **4040**: The handler with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n",
        "operationId": "deviceEvents_handlers_testExisting",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/HandlerId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HandlerTestResponse"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/test/kafka": {
      "post": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Test unregistered kafka event handlers. The handler will be created based on the request body\n and will be forgotten after the test. Use the `domain` query parameter to specify\n the domain, otherwise the domain of user authorizing the request will be selected.\n\n ## Additional information\n\n See the description of /deviceEvents/handler/kafka endpoint for more details about the request body.\n <br>\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4002**: Kafka custom config is invalid. If your config contains 'sasl.jaas.config', wrap the 'username' and 'password' fields using a backslash and double quote character on each side.\n\n **4003**: Kafka domain property is not configured for this domain.\n\n **4006**: The provided bootstrap server(s) is invalid or forbidden.\n\n **4041**: The domain with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n\n\n ## Usage example\n\n Prepare your Kafka producer configuration, an appropriate event filter and use them in the request body. The following example\n tests a handler from custom Kafka properties:\n </br> </br>\n ```\n {\n    \"type\": \"kafka\",\n    \"name\": \"Custom Kafka event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"type\": \"custom\",\n      \"value\": \"bootstrap.servers=kafka-cloud.com:9093\\nsecurity.protocol=SASL_PLAINTEXT\\nsasl.mechanism=SCRAM-SHA-256\\nsasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=kafka-user password=pass;\",\n      \"topic\": \"coiote.deviceEvents\",\n      \"headers\": {\n        \"Origin\": \"IoT-DM\"\n      }\n    },\n    \"filter\": {\n      \"type\": \"lifecycle\",\n      \"eventTypes\": [ \"deviceCreated\" ]\n    },\n    \"description\": \"This handler forwards data to kafka-cloud.com\"\n }\n ```\n </br> </br>\n The following example tests a handler from Kafka config stored in domain properties:\n </br> </br>\n ```\n {\n    \"type\": \"kafka\",\n    \"name\": \"Domain Kafka event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"type\": \"domainProperty\",\n      \"topic\": \"coiote.deviceEvents\",\n      \"headers\": {\n        \"Origin\": \"IoT-DM\"\n      }\n    },\n    \"filter\": {\n      \"type\": \"lifecycle\",\n      \"eventTypes\": [ \"deviceCreated\" ]\n    },\n    \"description\": \"This handler forwards data to kafka-cloud.com\"\n }\n ```\n </br> </br>\n ",
        "operationId": "deviceEvents_handlers_testKafka",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceKafkaEventsHandlerCreateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HandlerTestResponse"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/test/webhook": {
      "post": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Test unregistered webhook event handlers. The handler will be created based on the request body\n and will be forgotten after the test. Use the `domain` query parameter to specify\n the domain, otherwise the domain of user authorizing the request will be selected.\n\n ## Additional information\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4005**: The provided handler uri is invalid or forbidden.\n\n **5030**: System encountered error while processing request, please try again later.\n\n ## Usage example\n For details about the request body, go to the description of /deviceEvents/handler/webhook endpoint.\n Prepare your Webhook connection configuration - URI, credentials and method. Choose an appropriate event filter and use them in the request body.\n The following example of the request body sets up a handler that forwards data to InfluxDB Cloud bucket.\n </br> </br>\n ```\n {\n    \"type\": \"webhook\",\n    \"name\": \"Influx event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"method\": \"post\",\n      \"format\": \"influxDb\",\n      \"additionalHeaders\": {\n           \"Authorization\": \"Token <enter your token>\"\n      },\n      \"uri\": \"https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?bucket=<enter bucket ID>\",\n      \"auth\": null\n    },\n    \"filter\": {\n      \"type\": \"telemetry\",\n      \"lwm2mUrls\": [ \"/6/0/0\" ]\n    },\n    \"description\": \"This handler forwards location data to InfluxDB Cloud\"\n }\n ```\n </br> </br>\n",
        "operationId": "deviceEvents_handlers_testWebhook",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceWebhookEventsHandlerCreateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HandlerTestResponse"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/webhook": {
      "post": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Create an event handler that forwards events to a publicly accessible HTTP endpoint.\n Use the `domain` query parameter to specify\n the domain, otherwise the domain of user authorizing the request will be selected\n\n ## Additional information\n\n ### 1. Configuring the connection\n\n Each Webhook event handler can forward events both to HTTP and HTTPS endpoints. If you specify the\n target URL to be HTTPS, handler execution will fail if the certificate is not valid.\n\n The requests can be authorized in one of three ways:\n\n - using basic auth (user and password), by specifying `connectionConfig.auth` field of the request body,\n - using bearer auth (token), by specifying `connectionConfig.token` field of the request body,\n - using custom static header, by specifying `connectionConfig.additionalHeaders` field of the request body.\n\n The examples below show how to configure each type of authorization:\n\n </br>\n #### Basic\n </br>\n ```\n {\n   \"connectionConfig\": {\n      \"type\": \"basic\",\n      \"user\": \"<your username>\",\n      \"password\": \"<your password>\"\n   }\n   ...\n }\n ```\n </br> </br>\n\n #### Token\n </br>\n ```\n {\n   \"connectionConfig\": {\n      \"type\": \"token\",\n      \"token\": \"<your token>\"\n   }\n   ...\n }\n ```\n </br> </br>\n\n #### Custom header\n </br>\n ```\n {\n   \"connectionConfig\": null,\n   \"additionalHeaders\": {\n      \"<custom authorization header>\": \"<header value>\"\n   }\n   ...\n }\n ```\n </br> </br>\n\n ### 2. Specifying delivery method and body format\n\n If you don't specify the HTTP method using `connectionConfig.method` field, the requests will be sent using HTTP POST. You can specify the method to be one of [ `\"post\"`, `\"put\"`, `\"patch\"` ].\n\n\n By default, the events are represented as JSON when the request body is prepared. You can change the format to\n [InfluxDB line protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) by\n setting the `connectionConfig.format` field to `\"influxDb\"`.\n\n ### 3. Selecting forwarded events by applying filter\n\n \n Each handler can forward events of only one of two types:\n\n - **Telemetry** events - emitted each time a change in device's data is spotted by the system.\n\n - **Device** events - emitted each time device's state in the system changes.\n\n **Telemetry** events are usually emitted when the device sends a LwM2M Notify message to the server, device sends LwM2M Send message to the server,\n or the server carries out Read on device resource. For handlers that forward `telemetry` data, you can state for which LwM2M objects and resources\n the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition.\n\n </br>\n For example, the following filter allows all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303):\n </br> </br>\n\n ```\n \"filter\": {\n  \"type\": \"telemetry\",\n  \"lwm2mUrls\": [ \"/6/0/0\", \"/3303\" ]\n }\n ```\n\n </br> </br>\n\n **Device** events are emitted when one of the following takes place:\n\n - `deviceCreated` - when a device is added to the system,\n - `deviceFirstRegistration` - when a device connects for the first time,\n - `deviceUpdatedViaWrite` - when server carries out a Write to a device's resource,\n - `deviceUpdatedViaFota` - when server finishes execution of Firmware Upgrade (FOTA) on a device,\n - `deviceDeleted` - when a device is deleted from the system,\n \n </br>\n For example, the following filter allows events when device registers or carries out FOTA:\n </br> </br>\n\n ```\n \"filter\": {\n  \"type\": \"lifecycle\",\n  \"eventTypes\": [ \"deviceFirstRegistration\", \"deviceUpdatedViaFota\" ]\n }\n ```\n\n\n </br> </br>\n\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4004**: The available handlers limit has been reached.\n\n **4005**: The provided handler uri is invalid or forbidden.\n\n **4041**: The domain with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n\n </br>\n\n ## Usage example\n\n Prepare your Webhook connection configuration - URI, credentials and method. Choose a proper event filter and use them in the request body.\n The following example of the request body sets up a handler that forwards data to InfluxDB Cloud bucket:\n </br> </br>\n ```\n {\n    \"type\": \"webhook\",\n    \"name\": \"Influx event handler\",\n    \"enabled\": true,\n    \"connectionConfig\": {\n      \"method\": \"post\",\n      \"format\": \"influxDb\",\n      \"additionalHeaders\": {\n        \"Authorization\": \"Token <enter your token>\"\n      },\n      \"uri\": \"https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?bucket=<enter bucket ID>\",\n      \"auth\": null\n    },\n    \"filter\": {\n      \"type\": \"telemetry\",\n      \"lwm2mUrls\": [ \"/6/0/0\" ]\n    },\n    \"description\": \"This handler forwards location data to InfluxDB Cloud\"\n }\n ```\n </br> </br>\n ",
        "operationId": "deviceEvents_handlers_createWebhookEventHandler",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceWebhookEventsHandlerCreateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HandlerId"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/webhook/{id}": {
      "put": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Update an event handler that forwards events to a publicly accessible HTTP endpoint.\n\n ## Additional information\n You must provide the handler ID as `id`.\n For information about the request body, see the description of POST /deviceEvents/handler/webhook.\n Possible custom error codes in the response body:\n\n **4000**: Payload is invalid.\n\n **4005**: The provided handler uri is invalid or forbidden.\n\n **5030**: System encountered error while processing request, please try again later.\n ",
        "operationId": "deviceEvents_handlers_updateWebhookEventHandler",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/HandlerId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceWebhookEventsHandlerUpdateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceEventsHandler"
                }
              }
            }
          }
        }
      }
    },
    "/deviceEvents/handler/{id}": {
      "get": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Get a given event handler.\n\n ## Additional information\n You must provide event handler ID as the path parameter `id`.\n<br>\n Possible custom error codes in the response body:\n\n **4040**: The handler with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n ",
        "operationId": "deviceEvents_handlers_getHandler",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/HandlerId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceEventsHandler"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "DeviceEventHandlers"
        ],
        "description": "\n ## Overview\n Delete a given event handler.\n\n ## Additional information\n You must provide event handler ID as the path parameter `id`.\n <br>\n Possible custom error codes in the response body:\n\n **4001**: Handler id must be a 24-byte hexadecimal string representation.\n\n **4040**: The handler with the given id was not found.\n\n **5030**: System encountered error while processing request, please try again later.\n ",
        "operationId": "deviceEvents_handlers_deleteHandler",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/HandlerId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      }
    },
    "/deviceLifecycleManagement/factoryTesting/activate": {
      "post": {
        "tags": [
          "DeviceLifecycleManagement"
        ],
        "description": "\n ## Overview\n Activate the factory testing phase for a specified device.\n ## Additional information\n In this state, the device won't be operational.\n You must provide `endpointName` in the request body. Domain is optional.\n ## Usage example\n ```\n {\n  \"endpointName\": \"deviceEndpointName\",\n  \"domain\": \"/testDomain/\"\n}\n```\n### Factory testing state will be automatically deactivated after 72 hours.",
        "operationId": "deviceLifecycleManagement_factoryTesting_activate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "endpointName": {
                    "$ref": "#/components/schemas/EndpointName"
                  },
                  "domain": {
                    "nullable": true,
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/DomainId"
                      }
                    ]
                  }
                },
                "required": [
                  "endpointName"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/deviceLifecycleManagement/factoryTesting/deactivate": {
      "post": {
        "tags": [
          "DeviceLifecycleManagement"
        ],
        "description": "\n ## Overview\n Deactivate the factory testing phase for a specified device.\n ## Additional information\n Deactivating results in restoring the device to the state after bootstrapping.\n You must provide `endpointName` in the request body. Domain is optional.\n ## Usage example\n ```\n {\n  \"endpointName\": \"deviceEndpointName\",\n  \"domain\": \"/testDomain/\"\n}\n```\n",
        "operationId": "deviceLifecycleManagement_factoryTesting_deactivate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "endpointName": {
                    "$ref": "#/components/schemas/EndpointName"
                  },
                  "domain": {
                    "nullable": true,
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/DomainId"
                      }
                    ]
                  }
                },
                "required": [
                  "endpointName"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/alias": {
      "post": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Set an alias for the LwM2M URL for the device with the provided identity.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n **4040**: The device with the provided ID was not found.\n\n **4041**: The LwM2M resource with the provided URL was not found.\n\n **4091**: The alias already exists for a given device for url: $url.\n ## Usage example\n Provide device identity as the path parameter `deviceId` and use the following request body:\n\n<br>\n\n ```\n{\n  \"lwm2mUrl\": \"/3/0/13\",\n  \"alias\": \"customAlias\"\n}\n```\n ",
        "operationId": "deviceMonitoring_setAlias",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lwm2mUrl": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Lwm2mUrl"
                      }
                    ],
                    "example": "/3/0/13"
                  },
                  "alias": {
                    "$ref": "#/components/schemas/Lwm2mUrlAlias"
                  }
                },
                "required": [
                  "lwm2mUrl",
                  "alias"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found or the LwM2M resource was not found. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/aliases": {
      "get": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Get all aliases of LwM2M resource URLs for the device with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n",
        "operationId": "deviceMonitoring_getAliases",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/Lwm2mUrlAlias"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/disable": {
      "post": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Disable a LwM2M resource monitoring on the device with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n ",
        "operationId": "deviceMonitoring_disableDeviceMonitoring",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/enable": {
      "post": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Create LwM2M resource monitoring on the device with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n ",
        "operationId": "deviceMonitoring_enableDeviceMonitoring",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/enabled": {
      "get": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Get information whether LwM2M resource monitoring is enabled for the device with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n ",
        "operationId": "deviceMonitoring_isMonitoringEnabled",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringEnabledResponse"
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/device/{deviceId}/resourceUrl/{lwm2mUrl}": {
      "delete": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Delete an alias on the provided LwM2M resource URL for the device with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`, and LWM2M Url as the path parameter `lwm2mUrl` in format '/x/y/z' with numeric values (for example /3/0/13)\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n **4040**: The device with the provided ID was not found.\n\n **4041**: The LwM2M resource with provided URL was not found.\n ",
        "operationId": "deviceMonitoring_deleteAlias",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "lwm2mUrl",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mUrl"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The device with the provided ID was not found or no Lwm2m URL was found. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/group/{groupId}/disable": {
      "post": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Disable a LwM2M resource monitoring on all devices in the group with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`. You can also specify the includeSubgroups field in the request body.\n If the `includeSubgroups` is set to true monitoring on devices from descendant groups will also be disabled.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n ## Usage example\n Provide the full group identity as the path parameter `groupId` and use the following request body:\n\n<br>\n\n```\n{\n  \"includeSubgroups\": true\n}\n```\n ",
        "operationId": "deviceMonitoring_disableGroupMonitoring",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "includeSubgroups": {
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "The group with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/configuration/group/{groupId}/enable": {
      "post": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Enable a LwM2M resource monitoring on all devices in the group with the provided ID.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`. You can also specify the includeSubgroups field in the request body. If the `includeSubgroups` is set to true monitoring on devices from descendant groups will also be enabled.\n <br>\n Possible custom error codes in the response body:\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n ## Usage example\n Provide full group identity as the path parameter `groupId` and use the following request body:\n\n <br>\n\n```\n{\n  \"includeSubgroups\": true\n}\n```\n ",
        "operationId": "deviceMonitoring_enableGroupMonitoring",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "includeSubgroups": {
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "The group with the provided ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/data/{deviceId}/alias/{alias}": {
      "get": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Get a series of monitoring data from the device resource identified by its alias\n that were reported between the timeRangeStart (exclusive) and timeRangeEnd (inclusive).\n ## Additional information\n If the timeRangeEnd parameter is not provided the default value is the current time.\n The limit parameter specifies the maximum number of the returned data values (default and max value is 2048 records).\n If more records occur in the provided time range the hasNext value of the response is set to true\n and the lastPointTimestamp value represents time value of the last record.\n It allows you to access the next batch of the data by using lastPointTimestamp as the time range start value of the next query.\n <br>\n Possible custom error codes in the response body:\n\n **4000**: The provided time range was invalid. The start date must be earlier than the end date and they must be past dates.\n\n **4001**: The provided limit was invalid. It must be an integer between 1 and 2048.\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n **4040**: The device with the provided ID was not found.\n\n **4041**: The LwM2M resource with the provided alias was not found.\n\n **4042**: The LwM2M resource is outside of the monitored range. Objects with IDs between 1 and 65534 inclusive are monitored.\n\n **5030**: The system encountered an error while processing the request, please try again later.\n\n **5031**: Monitoring is not enabled.\n ## Usage example\n Provide device identity \"test-device-id\" as the path parameter `deviceId`, alias \"temperatureSensor\" as the path parameter `alias`,\n time range start in ISO format \"2022-12-01T08:05:35Z\" as the query parameter `timeRangeStart`.\n Provide the optional query parameters: \"1000\" as `limit` and \"2022-12-08T08:05:35Z\" as `timeRangeEnd`.\n ",
        "operationId": "deviceMonitoring_getMonitoringDataByAlias",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "alias",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mUrlAlias"
            }
          },
          {
            "name": "timeRangeStart",
            "in": "query",
            "required": true,
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "timeRangeEnd",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 2048
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The system encountered an error. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringDataResponse"
                }
              }
            }
          }
        }
      }
    },
    "/deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl}": {
      "get": {
        "tags": [
          "DeviceMonitoring"
        ],
        "description": "\n ## Overview\n Get a series of monitoring data from the device resource identified by its LwM2M URL\n that were reported between the timeRangeStart (exclusive) and timeRangeEnd (inclusive).\n ## Additional information\n If the timeRangeEnd parameter is not provided the current time is assumed to be the range end.\n The limit parameter specifies the maximum number of the returned data values (default and max value is 2048 records).\n If more records occur in the provided time range, the hasNext value of the response is set to true\n and the lastPointTimestamp value represents time value of the last record.\n It allows you to access the next batch of the data by using lastPointTimestamp as the time range start value of the next query.\n <br>\n Possible custom error codes in the response body:\n\n **4000**: The provided time range was invalid. The start date must be earlier than the end date and they must be past dates.\n\n **4001**: The provided limit was invalid. It must be an integer between 1 and 2048.\n\n **4003**: The provided LwM2M URL was invalid. The correct format is '/x/y/z' with numeric values.\n\n **4030**: The user does not have the required permissions to perform monitoring actions.\n\n **4040**: The device with the provided ID was not found.\n\n **4041**: The LwM2M resource with provided URL was not found.\n\n **4042**: The LwM2M resource is outside of the monitored range. Objects with IDs between 1 and 65534 inclusive are monitored.\n\n **5030**: The system encountered an error while processing the request, please try again later.\n\n **5031**: Monitoring is not enabled.\n ## Usage example\n Provide device identity \"test-device-id\" as the path parameter `deviceId`, lwm2m url \"/3/0/13\" as the path parameter `lwm2mUrl`,\n time range start in ISO format \"2022-12-01T08:05:35Z\" as the query parameter `timeRangeStart`\n and optional query parameters: \"1000\" as `limit` and \"2022-12-08T08:05:35Z\" as `timeRangeEnd`.\n ",
        "operationId": "deviceMonitoring_getMonitoringDataByUrl",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "lwm2mUrl",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mUrl"
            }
          },
          {
            "name": "timeRangeStart",
            "in": "query",
            "required": true,
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "timeRangeEnd",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 2048
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "404": {
            "description": "The system encountered an error. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The user does not have access to this action. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "The system encountered an error while processing the request, please try again later.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid. An accompanying error message and code in the response body explain further the reason.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringDataResponse"
                }
              }
            }
          }
        }
      }
    },
    "/devices": {
      "get": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Get devices using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving devices with different criteria:\n <br>\n To get all devices **do not use any criteria**.\n\n <br>\n\n To get devices with _id_ 'example', use:\n\n\n ```\n id eq 'example'\n ```\n\n <br>\n\n To get device with _model name_ containing 'example' string, use:\n\n\n ```\n modelName strcontains 'example'\n ```\n\n <br>\n To get devices, that successfully communicated with the system after 2012-09-01T08:51:23.180Z, use:\n\n```\n lastContactTime gt '2012-09-01T08:51:23.180Z'\n```\n <br>\n To get devices that have the property endpointName, use:\n\n ```\n properties.endpointName exists\n ```\n\n <br>\n\n To get devices with combined criteria, use:\n\n\n ```\n id eq 'example', modelName strcontains 'example'\n ```\n",
        "operationId": "devices_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **bootstrap** (boolean) : eq\n- **connectorType** (#/components/schemas/ConnectorType) : eq, ne, in, nin, exists, notexists\n- **blacklisted** (boolean) : eq\n- **managementEnabled** (boolean) : eq\n- **lastSessionTime** (string($date-time)) Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastContactTime** (string($date-time)) Time of the last successful network communication with a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastRegisterTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **firstRegisterTime** (string($date-time)) Time of the first successful register request from a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **ipAddress** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **serialNumber** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **oui** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **modelName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **hardwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **softwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **productClass** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **manufacturer** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **friendlyName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **domain** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **securityMode** (#/components/schemas/SecurityMode) : eq, ne, in, nin, exists, notexists\n- **directGroups** ([string]) : contains, notcontains, containsany\n- **groups** ([string]) : contains, notcontains, containsany\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DeviceQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DeviceId"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Create a new device. Provided identity must be unique.\n ## Additional information\n      You must provide information about device identity, domain, security and connector type.\n If you do not provide device identity, provide properties.endpointName instead.\n ## Usage example\n The following is an example of the request body for the creation of a device:\n```\n{\n  \"connectorType\": \"management\",                               ## provide connector type\n  \"directGroups\": [\n    \"root.mt.exampleGroup\"                                     ## provide groups that created device will belong to\n  ],\n  \"properties\": {\n    \"endpointName\": \"exampleUniqueEndpointName\",               ## provide unique endpoint name\n    \"exampleAdditionalProperty\": \"exampleAdditionalValue\"      ## provide additional properties if applicable\n  },\n  \"domain\": \"/exampleDomain/\",                                 ## provide domain name, domain must start and end with / sign\n  \"securityMode\": \"psk\",                                       ## provide security mode\n  \"dtlsIdentity\": \"exampleUniqueEndpointName\",                 ## provide dtlsIdentity, psk security mode requires this data to be provided\n  \"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}                        ## provide psk value\n}\n```\n You can pass more data in the request body. For further information see the example request body in the Request body section.\n\n\n **The \"dtlsIdentity\" and \"dtlsPsk\" parameters are used for both DTLS and TLS settings.**\n\n **The \"dtlsPsk\" parameter allows setting PSK in the following formats:**\n\n <br>\n\n Plain text:\n\n\n ```\n {\"PlainTextPsk\": \"...\"}\n ```\n\n <br>\n\n Hexadecimal:\n\n\n ```\n {\"HexadecimalPsk\": \"...\"}\n ```\n\n <br>\n\n Raw binary:\n\n\n ```\n {\"BinaryPsk\": [1,2,3]}\n ```\n\n  <br>\n\n For psk stored externally, use:\n\n\n ```\n {\"ExternalPsk\": {}}\n ```\n\n <br>\n\n For psk stored globally, use:\n\n\n ```\n {\"GlobalPsk\": {}}\n ```\n    ",
        "operationId": "devices_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessfulWithId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/devices/all/count": {
      "get": {
        "tags": [
          "Devices"
        ],
        "description": "Counts and returns the number of devices that match the specified search criteria. The endpoint may be removed without notice after February 2023",
        "operationId": "devices_count",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **bootstrap** (boolean) : eq\n- **connectorType** (#/components/schemas/ConnectorType) : eq, ne, in, nin, exists, notexists\n- **blacklisted** (boolean) : eq\n- **managementEnabled** (boolean) : eq\n- **lastSessionTime** (string($date-time)) Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastContactTime** (string($date-time)) Time of the last successful network communication with a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastRegisterTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **firstRegisterTime** (string($date-time)) Time of the first successful register request from a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **ipAddress** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **serialNumber** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **oui** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **modelName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **hardwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **softwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **productClass** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **manufacturer** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **friendlyName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **domain** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **securityMode** (#/components/schemas/SecurityMode) : eq, ne, in, nin, exists, notexists\n- **directGroups** ([string]) : contains, notcontains, containsany\n- **groups** ([string]) : contains, notcontains, containsany\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DeviceQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "format": "int32"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/devices/batch": {
      "post": {
        "tags": [
          "Devices"
        ],
        "description": "Method allows to create up to 100 new device entities.\n ## Overview\n Create a batch of new devices. Provided identities must be unique.\n ## Additional information\n      You must provide information about device identity, domain, security and connector type.\n If you do not provide device identity, provide properties.endpointName instead.\n ## Usage example\n The following is an example of the request body for the creation of 2 devices:\n```\n[\n {\n   \"connectorType\": \"management\",                               ## provide connector type\n   \"directGroups\": [\n     \"root.mt.exampleGroup\"                                     ## provide groups that created device will belong to\n   ],\n   \"properties\": {\n     \"endpointName\": \"exampleUniqueEndpointName1\",              ## provide unique endpoint name\n     \"exampleAdditionalProperty\": \"exampleAdditionalValue\"      ## provide additional properties if applicable\n   },\n   \"domain\": \"/exampleDomain/\",                                 ## provide domain name, domain must start and end with / sign\n   \"securityMode\": \"psk\",                                       ## provide security mode\n   \"dtlsIdentity\": \"exampleUniqueEndpointName1\",                ## provide dtlsIdentity, psk security mode requires this data to be provided\n   \"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}                        ## provide psk value\n },\n {\n   \"connectorType\": \"management\",                               ## provide connector type\n   \"directGroups\": [\n     \"root.mt.exampleGroup\"                                     ## provide groups that created device will belong to\n   ],\n   \"properties\": {\n     \"endpointName\": \"exampleUniqueEndpointName2\",              ## provide unique endpoint name\n     \"exampleAdditionalProperty\": \"exampleAdditionalValue\"      ## provide additional properties if applicable\n   },\n   \"domain\": \"/exampleDomain/\",                                 ## provide domain name, domain must start and end with / sign\n   \"securityMode\": \"psk\",                                       ## provide security mode\n   \"dtlsIdentity\": \"exampleUniqueEndpointName2\",                ## provide dtlsIdentity, psk security mode requires this data to be provided\n   \"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}                        ## provide psk value\n }\n]\n```\nYou can pass more data in the request body. For further information see the example request body in the Request body section.\n\n\n **The \"dtlsIdentity\" and \"dtlsPsk\" parameters are used for both DTLS and TLS settings.**\n\n **The \"dtlsPsk\" parameter allows setting PSK in the following formats:**\n\n <br>\n\n Plain text:\n\n\n ```\n {\"PlainTextPsk\": \"...\"}\n ```\n\n <br>\n\n Hexadecimal:\n\n\n ```\n {\"HexadecimalPsk\": \"...\"}\n ```\n\n <br>\n\n Raw binary:\n\n\n ```\n {\"BinaryPsk\": [1,2,3]}\n ```\n\n  <br>\n\n For psk stored externally, use:\n\n\n ```\n {\"ExternalPsk\": {}}\n ```\n\n <br>\n\n For psk stored globally, use:\n\n\n ```\n {\"GlobalPsk\": {}}\n ```\n    ",
        "operationId": "devices_createBatch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DeviceDTO"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceBatchAppResponse"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/devices/find/details": {
      "get": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Get devices using search criteria and specify device parameters to be returned.\n ## Additional information\n See the Parameters section for detailed information about:\n   - search criteria, available operators and values\n   - selection of the field to be returned\n   - limit of devices to be returned\n   - page bookmarks\n\n<br>\n\n If limit is not provided, 100 is set as the default limit.\n If pageBookmark is not provided, the request returns the first page.\n ## Usage example\n ### Retrieving devices with different criteria:\n <br>\n To get all devices **do not use any criteria**.\n\n <br>\n\n To get devices with id 'example', use:\n\n\n ```\n id eq 'example'\n ```\n\n <br>\n\n To get domain of devices with id 'example', use:\n\n\n ```\n seachCriteria: id eq 'example'\n fieldSelection: domain\n ```\n\n <br>\n\n To obtain the domains of the device with id 'example' with limit to 10 and next page bookmark, use:\n\n\n ```\n searchCriteria: id eq 'example'\n fieldSelection: domain\n limit: 10\n pageBookmark: <pageBookmark_from_previous_request>\n ```\n",
        "operationId": "devices_details",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **bootstrap** (boolean) : eq\n- **connectorType** (#/components/schemas/ConnectorType) : eq, ne, in, nin, exists, notexists\n- **blacklisted** (boolean) : eq\n- **managementEnabled** (boolean) : eq\n- **lastSessionTime** (string($date-time)) Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastContactTime** (string($date-time)) Time of the last successful network communication with a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastRegisterTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **firstRegisterTime** (string($date-time)) Time of the first successful register request from a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **ipAddress** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **serialNumber** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **oui** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **modelName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **hardwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **softwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **productClass** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **manufacturer** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **friendlyName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **domain** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **securityMode** (#/components/schemas/SecurityMode) : eq, ne, in, nin, exists, notexists\n- **directGroups** ([string]) : contains, notcontains, containsany\n- **groups** ([string]) : contains, notcontains, containsany\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DeviceQuery"
                }
              ],
              "default": ""
            }
          },
          {
            "name": "fieldSelection",
            "in": "query",
            "description": "\n Comma separated list of fields.\n\n ## Available fields:\n  - **id**\n- **bootstrap**\n- **connectorType**\n- **blacklisted**\n- **managementEnabled**\n- **lastSessionTime**\n- **lastContactTime**\n- **lastRegisterTime**\n- **firstRegisterTime**\n- **creationTime**\n- **ipAddress**\n- **serialNumber**\n- **oui**\n- **modelName**\n- **hardwareVersion**\n- **softwareVersion**\n- **productClass**\n- **manufacturer**\n- **description**\n- **friendlyName**\n- **domain**\n- **securityMode**\n- **directGroups**\n- **groups**\n- **properties**\n- **dtlsIdentity**\n- **dtlsPsk**\n\n ## Examples:\n - *id*\n - *id, modelName, domain*\n - *id, description*\n ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DeviceField"
                }
              ],
              "default": "id"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Specifies how many records are retrieved. The minimum value is 0, the maximum is 1000.",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "name": "pageBookmark",
            "in": "query",
            "description": "To get the first page, leave this parameter empty. To get the next page, use the bookmark value returned in the previous request.",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/PageBookmark"
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DevicesDetailsPage"
                }
              }
            }
          }
        }
      }
    },
    "/devices/{id}": {
      "get": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Get a device by its identity.\n ## Additional information\n You must provide device identity as the path parameter `id`.\n",
        "operationId": "devices_get",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeviceDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Update device entity by device identity.\n ## Usage example\n Provide device identity as the path parameter `id`. The following is an example of the request body adding and removing properties and groups, and changing friendly name.\n\n<br>\n```\n{\n  \"addProperties\": {\n    \"propertyToAdd\": \"propertyValueToAdd\",\n  },\n  \"removeProperties\": [\n    \"propertyNameToRemove\"\n  ],\n  \"addGroups\": [\n    \"root.mt.exampleGroup\"\n  ],\n  \"removeGroups\": [\n    \"root.mt.exampleGroupToRemove\"\n  ],\n  \"friendlyName\": \"exampleFriendlyName\"\n}\n```\nYou can pass more data in the request body. For more information, see the example request body in the Request body section.\n\n\n **The \"dtlsIdentity\" and \"dtlsPsk\" parameters are used for both DTLS and TLS settings.**\n\n **The \"dtlsPsk\" parameter allows setting PSK in the following formats:**\n\n <br>\n\n Plain text:\n\n\n ```\n {\"PlainTextPsk\": \"...\"}\n ```\n\n <br>\n\n Hexadecimal:\n\n\n ```\n {\"HexadecimalPsk\": \"...\"}\n ```\n\n <br>\n\n Raw binary:\n\n\n ```\n {\"BinaryPsk\": [1,2,3]}\n ```\n\n  <br>\n\n For psk stored externally, use:\n\n\n ```\n {\"ExternalPsk\": {}}\n ```\n\n <br>\n\n For psk stored globally, use:\n\n\n ```\n {\"GlobalPsk\": {}}\n ```\n    \n ### The \"removeGroups\" parameter will ignore device tenant group as device cannot leave it.\n ### For example, if device is in domain /a/ then parameter \"root.mt.a\" will be ignored.\n",
        "operationId": "devices_update",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeviceUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Devices"
        ],
        "description": "\n ## Overview\n Delete a device by its identity.\n ## Additional information\n You must provide device identity as the path parameter `id`.\n",
        "operationId": "devices_delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/dialects/addObject": {
      "put": {
        "tags": [
          "Dialects"
        ],
        "description": "\n ## Overview\n Add a LwM2M object specification overwriting an existing one.\n ## Additional information\n       You must provide a valid LwM2M object specification in the request body.\nAdded object specification is available to all devices.\nPayload must conform to the \"LWM2M XML Schema\",\nas defined by <http://www.openmobilealliance.org/tech/profiles/LWM2M.xsd>.\n\nExample specification: <https://openmobilealliance.org/tech/profiles/lwm2m/10241.xml>.\n\nID of the created dialect is returned.\n",
        "operationId": "dialects_addObjectOverwrite",
        "requestBody": {
          "content": {
            "text/xml": {
              "schema": {
                "$ref": "#/components/schemas/OmaXmlObjectDefinition"
              },
              "example": "<!--\n MIT License\nCopyright (c) 2018 AT&T\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-->\n\n<LWM2M xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://openmobilealliance.org/tech/profiles/LWM2M.xsd\">\n\t<Object ObjectType=\"MODefinition\">\n\t\t<Name>HostDeviceInfo</Name>\n\t\t<Description1><![CDATA[This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.]]></Description1>\n\t\t<ObjectID>10241</ObjectID>\n\t\t<ObjectURN>urn:oma:lwm2m:x:10241</ObjectURN>\n\t\t<LWM2MVersion />\n\t\t<ObjectVersion>1.0</ObjectVersion>\n\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t<Mandatory>Optional</Mandatory>\n\t\t<Resources>\n\t\t\t<Item ID=\"5905\"><Name>Host Device Manufacturer</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[Human readable host device manufacturer name]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5906\"><Name>Host Device Model Number</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[A host device model identifier (manufacturer specified string)]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5907\"><Name>Host Device Unique ID</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[The host device unique ID as assigned by an OEM, MNO, or other as the Device ID in the onboarding or manufacturing process.]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5908\"><Name>Host Device Software Version</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[Current software version of the host device. (manufacturer specified string).]]></Description>\n\t\t\t</Item></Resources>\n\t\t<Description2 />\n\t</Object>\n</LWM2M>"
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DialectCreateResult"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Dialects"
        ],
        "description": "\n ## Overview\n Add a LwM2M object specification.\n ## Additional information\n      You must provide a valid LwM2M object specification in the request body.\nAdded object specification is available to all devices.\nPayload must conform to the \"LWM2M XML Schema\",\nas defined by <http://www.openmobilealliance.org/tech/profiles/LWM2M.xsd>.\n\nExample specification: <https://openmobilealliance.org/tech/profiles/lwm2m/10241.xml>.\n\nID of the created dialect is returned.\n",
        "operationId": "dialects_addObject",
        "requestBody": {
          "content": {
            "text/xml": {
              "schema": {
                "$ref": "#/components/schemas/OmaXmlObjectDefinition"
              },
              "example": "<!--\n MIT License\nCopyright (c) 2018 AT&T\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-->\n\n<LWM2M xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://openmobilealliance.org/tech/profiles/LWM2M.xsd\">\n\t<Object ObjectType=\"MODefinition\">\n\t\t<Name>HostDeviceInfo</Name>\n\t\t<Description1><![CDATA[This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.]]></Description1>\n\t\t<ObjectID>10241</ObjectID>\n\t\t<ObjectURN>urn:oma:lwm2m:x:10241</ObjectURN>\n\t\t<LWM2MVersion />\n\t\t<ObjectVersion>1.0</ObjectVersion>\n\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t<Mandatory>Optional</Mandatory>\n\t\t<Resources>\n\t\t\t<Item ID=\"5905\"><Name>Host Device Manufacturer</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[Human readable host device manufacturer name]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5906\"><Name>Host Device Model Number</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[A host device model identifier (manufacturer specified string)]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5907\"><Name>Host Device Unique ID</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[The host device unique ID as assigned by an OEM, MNO, or other as the Device ID in the onboarding or manufacturing process.]]></Description>\n\t\t\t</Item>\n\t\t\t<Item ID=\"5908\"><Name>Host Device Software Version</Name>\n\t\t\t\t<Operations>R</Operations>\n\t\t\t\t<MultipleInstances>Multiple</MultipleInstances>\n\t\t\t\t<Mandatory>Mandatory</Mandatory>\n\t\t\t\t<Type>String</Type>\n\t\t\t\t<RangeEnumeration></RangeEnumeration>\n\t\t\t\t<Units></Units>\n\t\t\t\t<Description><![CDATA[Current software version of the host device. (manufacturer specified string).]]></Description>\n\t\t\t</Item></Resources>\n\t\t<Description2 />\n\t</Object>\n</LWM2M>"
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DialectCreateResult"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/domains": {
      "get": {
        "tags": [
          "Domains"
        ],
        "description": "\n ## Overview\n Get domains using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving domains with different criteria:\n <br>\n To get all domains **do not use any criteria**.\n\n <br>\n\n To get domains with id 'example', use:\n\n\n ```\n id eq 'example'\n ```\n\n <br>\n\n To get domains with description containing 'example' string, use:\n\n\n ```\n description strcontains 'example'\n ```\n\n <br>\n\n To get domains with combined criteria, use:\n\n\n ```\n id eq 'example', description strcontains 'example'\n ```\n",
        "operationId": "domains_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DomainQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DomainId"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Domains"
        ],
        "description": "\n ## Overview\n Create or update an existing domain entity.\n ## Additional information\n Domain identity consist of the root domain name **/** followed by any number of sub-domain names. A sub-domain name consists of any number of alphanumeric or '_' characters followed by '/'.\n For example, domain identity: **/domain/sub_domain/** consists of 3 domain names: **/** which is parent of **domain/** which is parent of **sub_domain/**.\n If posted domain identity contains nonexistent ancestor, then ancestor hierarchy will be created automatically\n ## Usage example\n Provide full domain identity and description in the request body:\n\n <br>\n\n ```\n{\n  \"id\": \"/example/example2/\",                             ## provide full domain path\n  \"description\": \"example description\"                    ## provide domain description\n}\n ```\n",
        "operationId": "domains_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DomainDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/domains/{id}": {
      "get": {
        "tags": [
          "Domains"
        ],
        "description": "\n ## Overview\n Get a domain by its identity.\n ## Additional information\n You must provide full domain identity as the path parameter `id`.\n Domain identity consist of the root domain name **/** followed by any number of sub-domain names. A sub-domain name consists of any number of alphanumeric or '_' characters followed by '/'.\n For example, domain identity: **/domain/sub_domain/** consists of 3 domain names: **/** which is parent of **domain/** which is parent of **sub_domain/**.\n",
        "operationId": "domains_get",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DomainWithPropertiesDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Domains"
        ],
        "description": "\n ## Overview\n Update specific domain information.\n ## Additional information\n You must provide full domain identity as the path parameter `id`.\n Domain identity consist of the root domain name **/** followed by any number of sub-domain names. A sub-domain name consists of any number of alphanumeric or '_' characters followed by '/'.\n For example, domain identity: **/domain/sub_domain/** consists of 3 domain names: **/** which is parent of **domain/** which is parent of **sub_domain/**.\n ## Usage example\n Provide full domain identity as the path parameter `id` and use the following request body:\n\n <br>\n\n ```\n{\n  \"newDescription\": \"string\"                         ## provide new domain description\n}\n```\n",
        "operationId": "domains_update",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "newDescription": {
                    "type": "string"
                  }
                },
                "required": [
                  "newDescription"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Domains"
        ],
        "description": "\n ## Overview\n Delete existing domain.\n ## Additional information\n You must provide full domain identity as the path parameter `id`.\n Domain identity consist of the root domain name **/** followed by any number of sub-domain names. A sub-domain name consists of any number of alphanumeric or '_' characters followed by '/'.\n For example, domain identity: **/domain/sub_domain/** consists of 3 domain names: **/** which is parent of **domain/** which is parent of **sub_domain/**.\n",
        "operationId": "domains_delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          },
          {
            "name": "recursively",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Get all available hyperscaler integrations.\n",
        "operationId": "extensions_listExtensions",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureDps": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Get an Azure DPS configuration information for the the user domain.\n",
        "operationId": "extensions_azureDps_getConfig",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AzureDpsExtensionConfig"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\nConfigure the Azure DPS for a the user domain.\n ## Additional information\n      You must provide Azure DPS `scopeId`, `enrollmentGroupSymmetricKey` and `dpsEndpoint`.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_DPS/Configuring_Azure_IoT_DPS_integration_extension/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"scopeId\": \"string\",                             ## Provide scope id value\n    \"enrollmentGroupSymmetricKey\": \"string\",         ## Provide group symmetric key\n    \"dpsEndpoint\": \"string\"                          ## Provide dps endpoint value\n  }\n}\n```\n",
        "operationId": "extensions_azureDps_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureDpsExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Delete the Azure DPS configuration for the user domain.\n",
        "operationId": "extensions_azureDps_delete",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureDps/testConfig": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Test whether the Azure DPS integration config works properly.\n ## Additional information\n      You must provide Azure DPS `scopeId`, `enrollmentGroupSymmetricKey`, `dpsEndpoint`.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_DPS/Configuring_Azure_IoT_DPS_integration_extension/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"scopeId\": \"string\",                             ## Provide scope id value\n    \"enrollmentGroupSymmetricKey\": \"string\",         ## Provide group symmetric key\n    \"dpsEndpoint\": \"string\"                          ## Provide dps endpoint value\n  }\n}\n```\n",
        "operationId": "extensions_azureDps_testConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureDpsExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureIotCentral": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Get Azure IoT Central configuration information for the user domain.\n",
        "operationId": "extensions_azureIotCentral_getConfig",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AzureIotCentralExtensionConfig"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Configure the Azure IoT Central for the user domain.\n ## Additional information\n      You must provide Azure IoT Central `apiToken`, `iotCentralHost`, `dpsHost` and sync enablement boolean value.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_Central/Configure_Azure_IoT_Central_integration/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"apiToken\": \"string\",                  ## Provide api token value\n    \"iotCentralHost\": \"string\",            ## Provide IoT Central host\n    \"dpsHost\": \"string\",                   ## Provide dps host value\n    \"syncEnabled\": false                   ## Decide if sync should be enabled\n  }\n}\n",
        "operationId": "extensions_azureIotCentral_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureIotCentralExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Delete the Azure IoT Central configuration for the user domain.\n",
        "operationId": "extensions_azureIotCentral_delete",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureIotCentral/testConfig": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Test whether the Azure IoT Central integration config works properly.\n ## Additional information\n      You must provide Azure IoT Central `apiToken`, `iotCentralHost`, `dpsHost` and sync enablement boolean value.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_Central/Configure_Azure_IoT_Central_integration/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"apiToken\": \"string\",                  ## Provide api token value\n    \"iotCentralHost\": \"string\",            ## Provide IoT Central host\n    \"dpsHost\": \"string\",                   ## Provide dps host value\n    \"syncEnabled\": false                   ## Decide if sync should be enabled\n  }\n}\n",
        "operationId": "extensions_azureIotCentral_testConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureIotCentralExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureIotHub": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Get Azure IoT Hub configuration information for the user domain.\n",
        "operationId": "extensions_azureIotHub_getConfig",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AzureIotHubExtensionConfig"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Configure the Azure IoT Hub for the user domain.\n ## Additional information\n      You must provide Azure IoT Hub `connectionString`, `storageConnectionString` and sync enablement boolean value.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_Hub/Configure_Azure_IoT_Hub_integration/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"connectionString\": \"string\",                  ## Provide connection string\n    \"storageConnectionString\": \"string\",           ## Provide storage connection string\n    \"syncEnabled\": false                           ## Decide if sync should be enabled\n  }\n}\n```\n",
        "operationId": "extensions_azureIotHub_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureIotHubExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Delete the Azure IoT Hub configuration for the user domain.\n",
        "operationId": "extensions_azureIotHub_delete",
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/azureIotHub/testConfig": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Test whether the Azure IoT Hub integration config works properly.\n ## Additional information\n      You must provide Azure IoT Hub `connectionString`, `storageConnectionString` and sync enablement boolean value.\n For more information visit [IoT Developer Zone](https://iotdevzone.avsystem.com/docs/Cloud_integrations/Azure_IoT/Azure_IoT_Hub/Configure_Azure_IoT_Hub_integration/)\n ## Usage example\n Provide required integration information in the request body:\n\n <br>\n\n```\n{\n  \"config\": {\n    \"connectionString\": \"string\",                  ## Provide connection string\n    \"storageConnectionString\": \"string\",           ## Provide storage connection string\n    \"syncEnabled\": false                           ## Decide if sync should be enabled\n  }\n}\n```\n",
        "operationId": "extensions_azureIotHub_testConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/AzureIotHubExtensionConfig"
                  }
                },
                "required": [
                  "config"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/hyperscaler/export": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Schedule and start a job to export group of devices to the configured hyperscaler.\n ## Additional information\n      You must provide Azure IoT Hub `groupId` and `excludeIntegrated` values. Group identity must be a full path to the group.\n The request returns the job ID, which can be used to check the job status. Status is available for 12 hours from the job start time.\n ## Usage example\n Provide required information in the request body:\n <br>\n\n```\n{\n  \"groupId\": \"root.mt.testGroup\",                      ## Provide full group path\n  \"excludeIntegrated\": false                           ## Decide if scheduling and starting export job should exclude already integrated groups\n}\n```\n\n",
        "operationId": "extensions_hyperscaler_exportToHyperscaler",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportToHyperscalerRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobId"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/hyperscaler/export/{jobId}": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Check the status of the export to hyperscaler job.\n ## Additional information\n You must provide job ID - `jobId`. The request returns job status information. Status is available for 12 hours from the job start time.\n",
        "operationId": "extensions_hyperscaler_getExportStatus",
        "parameters": [
          {
            "name": "jobId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/JobId"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "enum": [
                    "SUCCESS",
                    "FAILURE",
                    "IN_PROGRESS"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/extensions/hyperscaler/restartClient/{deviceId}": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Delete the azure client and re-initialize the connection.\n ## Additional information\n      You must provide device identity - `deviceId`.\n This method might help in case of issues with connectivity between the application and Azure (e.g. device connects to the application, but the user doesn't see data in Azure)\n",
        "operationId": "extensions_hyperscaler_restartClient",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          }
        }
      }
    },
    "/extensions/theThingsStack/gateway": {
      "post": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Method for adding a LoRa Gateway device to the platform.\n\n ## Additional information\n\n  If `hasEui` is set to true then EndpointName will also be a gateway's EUI in The Things Stack. Otherwise, no\n  EUI will be set for such gateway.\n\n LoRa Gateway specific fields:\n * ID - must match the regex pattern `[a-z0-9](?:[-]?[a-z0-9]){2,}` (see <a href=\"https://www.thethingsindustries.com/docs/reference/id-eui-constraints/#requirements-of-an-id\">documentation</a>).\n   This means the that ID  consists of lowercase letters and numbers with a possible dash within.\n * FrequencyPlan - must match one of the specified <a href=\"https://www.thethingsindustries.com/docs/reference/frequency-plans\">here</a> plans.\n * EndpointName if `hasEui` is set to true - must be a 16-digit hexadecimal number (see <a href=\"https://www.thethingsindustries.com/docs/reference/id-eui-constraints/#requirements-of-an-eui\">documentation</a>).\n * AntennaGain - optional, floating point number.\n\n\n If optional query param `domain` is provided then it's setup configuration is used and device will be created\n in provided domain.\n\n Possible custom error codes in the response body:\n <br/>\n\n\n\n**4000** The request body is invalid. Correct it according to the returned message.\n\n\n**4001** The request failed on the TTS api side. Correct it according to the returned message.\n\n\n**4002** Connection to TTS failed, please check provided URL.\n\n\n**4003** Provided EUI is already taken in TTS.\n\n\n**4004** Provided gateway id is already taken in TTS\n\n\n**4030** The user does not have necessary permissions to perform requested action. Check if you have proper permissions to create e.g. bootstrap-supporting device or certificate security mode\n\n\n**4041** The integration has not been set up in domain.\n\n\n**4090** Such a LoRa Gateway already exists in the IoT platform. Try different <i>endpoint name</i>.\n\n\n**5000** The platform has encountered unknown error. Please try again later.\n\n\n**5001** The platform has encountered error when accessing TTS service. Please try again later.\n\n\n**5010** The LoRaWAN Gateway feature is not enabled on this platform.\n\n\n ## Method usage example\n <br>\n\n```\n{\n  \"id\": \"unique-id\",\n  \"endpointName\": \"0123456789ABCDEF\",\n  \"hasEui\": true,\n  \"name\": \"MyGateway\",\n  \"frequencyPlan\": \"EU_433\",\n  \"antennaGain\": 1.0,\n  \"lwm2m\": {\n    \"securityMode\": \"psk\",\n    \"dtlsIdentity\": \"MyUniqueIdentity\",\n    \"dtlsPsk\": {\n      \"PlainTextPsk\": \"MySecurePsk\"\n    }\n  }\n}\n```\n\nIf you have already uploaded a certificate to the platform using the DTLS/TLS Certificates panel then you can add a LoRa gateway using:\n\n```\n{\n  \"id\": \"unique-id\",\n  \"endpointName\": \"0123456789ABCDEF\",\n  \"hasEui\": true,\n  \"name\": \"MyGateway\",\n  \"frequencyPlan\": \"EU_433\",\n  \"antennaGain\": 1.0,\n  \"lwm2m\": {\n    \"securityMode\": \"cert\"\n  }\n}\n```\n\n\n\n\n\n **The \"dtlsIdentity\" and \"dtlsPsk\" parameters are used for both DTLS and TLS settings.**\n\n **The \"dtlsPsk\" parameter allows setting PSK in the following formats:**\n\n <br>\n\n Plain text:\n\n\n ```\n {\"PlainTextPsk\": \"...\"}\n ```\n\n <br>\n\n Hexadecimal:\n\n\n ```\n {\"HexadecimalPsk\": \"...\"}\n ```\n\n <br>\n\n Raw binary:\n\n\n ```\n {\"BinaryPsk\": [1,2,3]}\n ```\n\n  <br>\n\n For psk stored externally, use:\n\n\n ```\n {\"ExternalPsk\": {}}\n ```\n\n <br>\n\n For psk stored globally, use:\n\n\n ```\n {\"GlobalPsk\": {}}\n ```\n    \n\n",
        "operationId": "extensions_theThingsStack_createGateway",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoraGatewayDTO"
                  }
                ],
                "example": {"id":"string","endpointName":"0000000000000000","hasEui":true,"name":"string","frequencyPlan":"EU_433","antennaGain":1.0,"lwm2m":{"securityMode":"psk","dtlsIdentity":"string","dtlsPsk":{"PlainTextPsk":"string"},"bootstrapSupported":true}}
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessfulMessage"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/theThingsStack/gateway/{endpointName}": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Method for obtaining a LoRa Gateway device from the platform.\n\n Possible custom error codes in the response body:\n <br/>\n\n\n\n**4030** The user does not have necessary permissions to perform requested action. Check if you have proper permissions to create e.g. bootstrap-supporting device or certificate security mode\n\n\n**4040** Gateway not found.\n\n\n**5000** The platform has encountered unknown error. Please try again later.\n\n\n**5001** The platform has encountered error when accessing TTS service. Please try again later.\n\n\n**5010** The LoRaWAN Gateway feature is not enabled on this platform.\n\n\n       ",
        "operationId": "extensions_theThingsStack_getGateway",
        "parameters": [
          {
            "name": "endpointName",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/EndpointName"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoraGatewayDTO"
                }
              }
            }
          }
        }
      }
    },
    "/extensions/theThingsStack/integration": {
      "get": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Method for obtaining information about current domain's The Things Stack integration.\n\n Possible custom error codes in the response body:\n <br/>\n\n \n\n**4030** The user does not have necessary permissions to perform requested action. Check if you have proper permissions to create e.g. bootstrap-supporting device or certificate security mode\n\n\n**4042** The domain which was provided cannot be found.\n\n\n**5010** The LoRaWAN Gateway feature is not enabled on this platform.\n\n\n**5000** The platform has encountered unknown error. Please try again later.\n\n\n       ",
        "operationId": "extensions_theThingsStack_getIntegration",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TheThingsStackIntegrationInformationDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Method to setup a The Things Stack cloud integration in domain. It's also used to override existing settings.\n\n ## Additional information\n Console server url must be a valid https url\n LNS server url must be a valid websocket (wss) url\n\n Possible custom error codes in the response body:\n <br/>\n\n \n\n**4000** The request body is invalid. Correct it according to the returned message.\n\n\n**4030** The user does not have necessary permissions to perform requested action. Check if you have proper permissions to create e.g. bootstrap-supporting device or certificate security mode\n\n\n**4042** The domain which was provided cannot be found.\n\n\n**5010** The LoRaWAN Gateway feature is not enabled on this platform.\n\n\n**5000** The platform has encountered unknown error. Please try again later.\n\n\n## Method usage example\n <br>\n\n```\n{\n  \"consoleServerUrl\": \"https://thethings.example.com\",\n  \"lnsServerUrl\": \"wss://thethings.example.com:8887\",\n  \"username\": \"yourUsernameInTheThingsStackCloud\",\n  \"personalApiKey\": \"NNSXS.XXXXXXXXX\"\n}\n```\n",
        "operationId": "extensions_theThingsStack_setupIntegration",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TheThingsStackIntegrationCreationDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      },
      "delete": {
        "tags": [
          "Extensions"
        ],
        "description": "\n ## Overview\n Method for removing The Things Stack integration from current domain.\n\n Possible custom error codes in the response body:\n <br/>\n\n \n\n**4030** The user does not have necessary permissions to perform requested action. Check if you have proper permissions to create e.g. bootstrap-supporting device or certificate security mode\n\n\n**4042** The domain which was provided cannot be found.\n\n\n**5010** The LoRaWAN Gateway feature is not enabled on this platform.\n\n\n**5000** The platform has encountered unknown error. Please try again later.\n\n\n       ",
        "operationId": "extensions_theThingsStack_deleteIntegration",
        "parameters": [
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DomainId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "204": {
            "description": "Success"
          }
        }
      }
    },
    "/firmwareUpdate/configurations": {
      "get": {
        "tags": [
          "Firmware Update Configuration"
        ],
        "description": " ## Overview\n Get all firmware update configurations.\n\n ## Additional information\n The firmware update configurations returned in this request might be expired.\n To find out which configurations are expired look at the 'expirationDateTime'\n",
        "operationId": "firmwareUpdate_configurations_get",
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FirmwareUpdateConfiguration"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Firmware Update Configuration"
        ],
        "description": " ## Overview\n Create a configuration that can be later used to perform firmware update operation on a single device\n or a fleet of devices.\n\n ## Additional information\n Parameter `resourceId` refers to the firmware image file uploaded to the system. File can be uploaded using\n `Resources` API endpoint group. The `resourceId` will be returned as a response to successful upload.\n\n <br>\n When parameter `visibleInSubDomains` is set to `false`, this configuration won't be accessible to a user\n in a sub-domain.\n\n <br>\n `Multicomponent` configuration kind is a firmware update implementation specific to AVSystem Anjay LwM2M client.\n\n <br>\n Possible custom error codes in the response body:\n\n **4000**: Provided configuration is invalid\n\n **4001**: Specified resource is missing\n\n **4002**: Specified resource already expired\n\n ## Usage example\n The following is an example of the request body for `Basic` configuration with `Pull` delivery method:\n\n <br>\n```\n{\n  \"name\": \"Example basic name\",\n  \"notes\": \"Example notes\",\n  \"visibleInSubDomains\": true,\n  \"execution\": {\n    \"kind\": \"Basic\",\n    \"resourceId\": \"123\",\n    \"transfer\": {\n      \"deliveryMethod\": \"Pull\",\n      \"protocol\": \"COAPS\",\n      \"uriFormat\": \"DNS\"\n    },\n    \"timeout\": \"10m\"\n  }\n}\n```\n <br>\n The following is an example of the request body for `Basic` configuration with `Push` delivery method:\n\n <br>\n```\n{\n  \"name\": \"Example basic name\",\n  \"notes\": \"Example notes\",\n  \"visibleInSubDomains\": true,\n  \"execution\": {\n    \"kind\": \"Basic\",\n    \"resourceId\": \"321\",\n    \"transfer\": {\n      \"deliveryMethod\": \"Push\"\n    },\n    \"timeout\": \"10m\"\n  }\n}\n```\n <br>\n The following is an example of the request body for `Multicomponent` configuration:\n\n <br>\n```\n{\n  \"name\": \"Example multicomponent name\",\n  \"notes\": \"Example notes\",\n  \"visibleInSubDomains\": true,\n  \"execution\": {\n    \"kind\": \"Multicomponent\",\n    \"componentResources\": [\n      {\n        \"resourceId\": \"12\",\n        \"componentInstanceId\": 1\n      },\n      {\n        \"resourceId\": \"23\",\n        \"componentInstanceId\": 2\n      }\n    ],\n    \"transfer\": {\n      \"deliveryMethod\": \"Pull\",\n      \"protocol\": \"COAPS\",\n      \"uriFormat\": \"DNS\"\n    },\n    \"timeout\": \"10m\"\n  }\n}\n```\n",
        "operationId": "firmwareUpdate_configurations_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FirmwareUpdateConfigurationCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/FirmwareUpdateConfigurationId"
                    },
                    "message": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/firmwareUpdate/configurations/{id}": {
      "get": {
        "tags": [
          "Firmware Update Configuration"
        ],
        "description": " ## Overview\n Get the firmware update configuration with the provided ID\n\n ## Additional information\n You must provide firmware update configuration identity as the path parameter id. The returned firmware update configuration might be expired.\n To find out which configurations are expired look at the 'expirationDateTime'\n\n <br>\n Possible custom error codes in the response body:\n\n **4040**: Firmware Update Configuration does not exist\n\n\n ## Usage example\n Provide the FOTA configuration identity as id to get the fotaConfig entity present in the database available for your user.\n",
        "operationId": "firmwareUpdate_configurations_getBy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FirmwareUpdateConfigurationId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FirmwareUpdateConfiguration"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Firmware Update Configuration"
        ],
        "description": " ## Overview\n Delete the firmware update configuration with the provided ID\n\n ## Additional information\n You must provide firmware update configuration identity as the path parameter `id`.\n Deleting the firmware update configuration will stop all the FOTA Campaigns or single Firmware Updates that use this configuration.\n\n <br>\n Possible custom error codes in the response body:\n\n **4040**: Firmware Update Configuration does not exist\n\n\n ## Usage example\n Provide the FOTA configuration identity as `id` to delete it and stop all firmware\n updates that use this configuration. Note that the operation cannot be reverted and a new firmware\n update configuration has to be created to schedule a new FOTA.\n",
        "operationId": "firmwareUpdate_configurations_deleteBy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FirmwareUpdateConfigurationId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/groups": {
      "get": {
        "tags": [
          "Groups"
        ],
        "description": "\n ## Overview\n Get groups using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving groups with different criteria:\n <br>\n To get all groups **do not use any criteria**.\n\n <br>\n\n To get groups with _id_ 'example', use:\n\n\n ```\n id eq 'example'\n ```\n\n <br>\n\n To get groups with _description_ containing 'example' string, use:\n\n\n ```\n description strcontains 'example'\n ```\n\n <br>\n\n To get groups with combined criteria, use:\n\n\n ```\n id eq 'example', description strcontains 'example'\n ```\n",
        "operationId": "groups_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GroupQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GroupId"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Groups"
        ],
        "description": "\n ## Overview\n Create or update existing group entity.\n ## Additional information\n Group identity consists of dot-separated names of all the parent groups and the group name itself. For example: *root.parent1.parent2.groupName*. When you provide a group id with parent group names that do not exist, then these parent groups are created automatically.\n ## Usage example\n Provide full group identity and description in the request body:\n\n <br>\n\n ```\n{\n \"id\": \"root.mt.exampleGroup\",                          ## provide full group identity\n \"description\": \"example description\"                   ## provide group description\n}\n ```\n",
        "operationId": "groups_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/groups/{id}": {
      "get": {
        "tags": [
          "Groups"
        ],
        "description": "\n ## Overview\n Get a group by its identity.\n ## Additional information\n You must provide the full group identity as the path parameter `id`. Group identity consists of dot-separated names of all the parent groups and the group name itself. For example: *root.parent1.parent2.groupName*.\n",
        "operationId": "groups_get",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Groups"
        ],
        "description": "\n ## Overview\n Update a group by its identity.\n ## Additional information\n You must provide the full group identity as the path parameter `id`. Group identity consists of dot-separated names of all the parent groups and the group name itself.\n For example: *root.parent1.parent2.groupName*.\n ## Usage example\n Provide full group identity as `id` and use the following request body:\n\n <br>\n\n ```\n{\n \"description\": \"example description\"\n}\n```\n",
        "operationId": "groups_update",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  }
                },
                "required": [
                  "description"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Groups"
        ],
        "description": "\n ## Overview\n Delete a group by its identity.\n ## Additional information\n You must provide the full group identity as the path parameter `id`. Group identity consists of dot-separated names of all the parent groups and the group name itself. For example: *root.parent1.parent2.groupName*.\n",
        "operationId": "groups_delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/instantiatedResources/dataModelDefinition/{deviceId}": {
      "get": {
        "tags": [
          "InstantiatedResources"
        ],
        "description": "\n ## Overview\n Get definitions of resources instantiated at a device for objects specified in a query parameter.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n You can specify resources that you want to retrieve as an array in a query parameter.\n If the parameter list is empty, then definitions of all instantiated resources are returned.\n Definitions of resources are encapsulated in the definition of the object containing these resources.\n The returned data does not include identifiers of object instance where the resource occurs. This information might be necessary, only if the object has more than one instance, since in the response there is no information which instance it is.\n Example parameters: `Device, Location`\n",
        "operationId": "instantiatedResources_dataModelDefinition",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "parameters",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ObjectDefinition"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/instantiatedResources/resourcesData/{deviceId}": {
      "get": {
        "tags": [
          "InstantiatedResources"
        ],
        "description": "\n ## Overview\n Get definitions and values of resources instantiated at a device for objects specified in a query parameter.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n You can specify resources that you want to have returned as an array in a query parameter.\n If a parameter list is empty, then definitions of all instantiated resources are returned.\n Definitions of resources contain a full data model path where the resource occurs and for that reason are duplicated for multiple-instance objects.\n Example parameters: `Device, Location`\n",
        "operationId": "instantiatedResources_resourcesData",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "parameters",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResourceInstanceData"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/monitoring": {
      "get": {
        "tags": [
          "LegacyMonitoringConfiguration"
        ],
        "description": "\n ## Overview\n Get existing monitoring instances using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving monitoring instances with different criteria:\n <br>\n To get all monitoring instances **do not use any criteria**.\n\n <br>\n\n To get monitoring instances that are active, use:\n\n\n ```\n active eq 'true'\n ```\n\n <br>\n\n To get monitoring instances which have sampling interval set to 60, use:\n\n\n ```\n samplingInterval eq '60'\n ```\n\n <br>\n\n To get monitoring instances with combined criteria, use:\n\n\n ```\n active eq 'true', samplingInterval eq '60'\n ```\n",
        "operationId": "legacyMonitoring_getMonitoringConfigurations",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** ([string]) : contains, notcontains, containsany\n- **samplingInterval** (integer($int32)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **active** (boolean) : eq\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **condition** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/MonitoringConfigurationQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "LegacyMonitoringConfiguration"
        ],
        "description": "\n ## Overview\n Create new monitoring instance.\n ## Additional information\n Monitoring can target groups. Groups must be provided with full path.\n ## Usage example\n The following is an example of the request body:\n\n <br>\n\n ```\n{\n  \"name\": \"string\",\n  \"targetGroups\": [\n    \"root.mt.targetGroup\"                                      ## Provide target group\n  ],\n  \"resourcesConfigurations\": [                                 ## Provide monitoring configuration information\n    {\n      \"displayName\": \"display name monitoring\",\n      \"resourceType\": \"Textual\",\n      \"source\": {\"SettingValueSource\": {\"name\": \"test\"}},\n      \"storeSamples\": true,\n      \"storeAggregates\": true,\n      \"isPassive\": true\n    }\n  ],\n  \"samplingIntervalSeconds\": 60,                               ## Provide data collecting interval\n  \"description\": \"description monitoring\",\n  \"isActive\": true                                             ## Decide if monitoring is active\n}\n```\n\n",
        "operationId": "legacyMonitoring_createMonitoring",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MonitoringConfigurationDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/monitoring/{monitoringName}": {
      "get": {
        "tags": [
          "LegacyMonitoringConfiguration"
        ],
        "description": "\n ## Overview\n Get monitoring information by monitoring ID.\n ## Usage example\n Provide monitoring name - `monitoringName`.\n",
        "operationId": "legacyMonitoring_getMonitoringConfiguration",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitoringConfigurationDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "LegacyMonitoringConfiguration"
        ],
        "description": "\n ## Overview\n Update monitoring configuration.\n ## Additional information\n Monitoring can target groups. Groups must be provided with full path.\n ## Usage example\n The following is an example of the request body:\n\n <br>\n\n ```\n {\n  \"name\": \"string\",\n  \"samplingIntervalSeconds\": 0,\n  \"addTargetGroups\": [\n    \"string\"                                                   ## Provide target groups to add if any\n  ],\n  \"removeTargetGroups\": [\n    \"string\"                                                   ## Provide target groups to remove if any\n  ],\n  \"removeResourcesConfigurations\": [\n    \"string\"                                                   ## Provide resource configuration to remove if any\n  ],\n  \"addResourcesConfigurations\": [                              ## Provide new resources configuration to add if any\n    {\n      \"displayName\": \"string\",\n      \"resourceType\": \"Textual\",\n      \"source\": {},\n      \"storeSamples\": true,\n      \"storeAggregates\": true,\n      \"isPassive\": true\n    }\n  ],\n  \"description\": \"string\",\n  \"isActive\": true,                                            ## Decide if monitoring is active\n  \"runCondition\": \"string\",                                    ## Provide run conditions if any\n  \"addExcludedGroupsPatterns\": [\n    \"string\"                                                   ## Provide excluded groups pattern to add if any\n  ],\n  \"removeExcludedGroupsPatterns\": [\n    \"string\"                                                   ## Provide excluded groups pattern to remove if any\n  ]\n}\n```\n",
        "operationId": "legacyMonitoring_updateMonitoring",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MonitoringConfigurationUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "LegacyMonitoringConfiguration"
        ],
        "description": "\n ## Overview\n Delete monitoring instance.\n ## Additional information\n Monitoring is targeted by its name.\n ## Usage example\n Provide monitoring name - `monitoringName`.\n",
        "operationId": "legacyMonitoring_removeMonitoring",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/monitoringData/aggregates/numerical/{monitoringName}/{groupId}/{resourceName}": {
      "get": {
        "tags": [
          "LegacyMonitoringData"
        ],
        "description": "\n ## Overview\n Get aggregated numerical resource data.\n ## Additional information\n The time span of single returned aggregate depends on requested time range (fromDate, toDate):\n less than one day - minute aggregates, less than one month - hour aggregates, otherwise - day aggregates.\n Default fromDate value is one day before toDate.\nDefault toDate value is current time.\n    \n ## Usage example\n Provide monitoring name - `monitoringName`, full group identity - `groupId`, resource name - `resourceName`\n and optional time range - `fromDate` and `toDate`.\n",
        "operationId": "legacyMonitoringData_aggregates_getNumericalAggregates",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          },
          {
            "name": "resourceName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fromDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "toDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NumericalAggregate"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/monitoringData/aggregates/textual/{monitoringName}/{groupId}/{resourceName}": {
      "get": {
        "tags": [
          "LegacyMonitoringData"
        ],
        "description": "\n ## Overview\n Get aggregated textual resource data.\n ## Additional information\n The time span of single returned aggregate depends on requested time range (fromDate, toDate):\n less than one day - minute aggregates, less than one month - hour aggregates, otherwise - day aggregates.\n Default fromDate value is one day before toDate.\nDefault toDate value is current time.\n    \n ## Usage example\n Provide monitoring name - `monitoringName`, full group identity - `groupId`, resource name - `resourceName`\n and optional time range - `fromDate` and `toDate`.\n",
        "operationId": "legacyMonitoringData_aggregates_getTextualAggregates",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          },
          {
            "name": "resourceName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fromDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "toDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TextualAggregate"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/monitoringData/moreSamples": {
      "get": {
        "tags": [
          "LegacyMonitoringData"
        ],
        "description": "\n ## Overview\n Get next sample batch for the cursor value obtained\n from GET on **/samples** or previous GET on **/moreSamples**.\n ## Additional information\n Default count is 512.\n Default fromDate value is one day before toDate.\nDefault toDate value is current time.\n    \n ## Additional information\n You must provide cursor integer value as the query parameter `cursor` and optionally count as the query parameter `count`.\n",
        "operationId": "legacyMonitoringData_getMoreSamples",
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": true,
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/SampleCursor"
            }
          },
          {
            "name": "count",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 512
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SampleBatch"
                }
              }
            }
          }
        }
      }
    },
    "/monitoringData/samples/{monitoringName}/{deviceId}": {
      "get": {
        "tags": [
          "LegacyMonitoringData"
        ],
        "description": "\n ## Overview\n Get cursor for all samples for a given monitoring within given time period.\n ## Additional information\n Default fromDate value is one day before toDate.\nDefault toDate value is current time.\n    \n ## Usage example\n Provide monitoring name - `monitoringName`, device identity - `deviceId`\n and optional time range - `fromDate` and `toDate`.\n",
        "operationId": "legacyMonitoringData_sampleCursor",
        "parameters": [
          {
            "name": "monitoringName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "fromDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "toDate",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SampleCursor"
                }
              }
            }
          }
        }
      }
    },
    "/observations": {
      "get": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Get observations using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving observations with different criteria:\n <br>\n To get all observations **do not use any criteria**.\n\n <br>\n\n To get observations with specified path, use:\n\n\n ```\n path eq 'Device.0.Manufacturer'\n ```\n\n <br>\n\n To get observations for device with _id_ containing 'example' string, use:\n\n\n ```\n id strcontains 'example'\n ```\n\n <br>\n\n To get observations with combined criteria, use:\n\n\n ```\n path eq 'Device.0.Manufacturer', id strcontains 'example'\n ```\n",
        "operationId": "observations_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **device** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **path** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ObservationQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ObservationId"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/observations/device/{deviceId}/{path}": {
      "get": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Get observations for a given device ID and a given path.\n ## Additional information\n You must provide the device identity as the path parameter `deviceId` and the path as the path parameter `path`.\n The ensureObservations task has to be enabled on the device.\n The path can point to Object, Object Instance or Resource.\n Example paths: 'Device', 'Device.0', 'Device.0.Current Time'.\n",
        "operationId": "observations_get",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mPath"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObservationData"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Create or update device observation for a given device ID and a given path.\n ## Additional information\n The path can point to Object, Object Instance or Resource.\n Example paths: 'Device', 'Device.0', 'Device.0.Current Time'.\n Valid observation attributes: 'pmin', 'pmax', 'gt', 'lt', 'st'.\n In case of an update, the observation attributes are overwritten.\n You can create ensureObservationTask if needed - include `createEnsureObserveIfNotExists` in the request body.\n ## Usage example\n Provide path parameters: `deviceId` - \"test-device-id\", `path` - \"Device.0.Manufacturer\" and include the following request body:\n\n <br>\n\n ```\n {\n  \"attributes\": [\n    {\n      \"name\": \"pmax\",                            ## Provide observation attribute name\n      \"value\": \"60\"                              ## Provide observation attribute value\n    }\n  ],\n  \"createEnsureObserveIfNotExists\": false        ## Decide if ensure observation task should be created also\n}\n ```\n",
        "operationId": "observations_createUpdate",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mPath"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObservationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Delete (cancel) observation for a given device ID and a given path.\n ## Additional information\n You must provide the device identity as the path parameter `deviceId` and the path as the path parameter `path`.\n The ensureObservations task has to be enabled on the device.\n The path can point to Object, Object Instance or Resource.\n Example paths: 'Device', 'Device.0', 'Device.0.Current Time'.\n",
        "operationId": "observations_cancel",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mPath"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/observations/group/resourcePath/{groupId}/{path}": {
      "post": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Create or update group observations for a given group and a given path.\n ## Additional information\n The path can point to Object, Object Instance or Resource.\n Example paths: 'Device', 'Device.0', 'Device.0.Current Time'.\n In case of an update, the observation attributes are overwritten.\n Group identity must be a full group path.\n ## Usage example\n Provide the path parameters: `groupId` - \"root.parent1.parent2.groupName\", `path` - \"Device.0.Manufacturer\" and include the following request body:\n\n <br>\n ```\n {\n  \"minPeriod\": 45,\n  \"maxPeriod\": 60\n}\n ```\n",
        "operationId": "observations_createUpdateForGroup",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mPath"
            },
            "example": "Device.0.Current Time"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GroupObservationRequest"
                  }
                ],
                "example": {"minPeriod":45,"maxPeriod":60}
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/observations/group/resourceUrl/{groupId}/{url}": {
      "post": {
        "tags": [
          "Observations"
        ],
        "description": "\n ## Overview\n Create or update group observations for  given group and a given LwM2M URL.\n ## Additional information\n An URL can point to Object, Object Instance or Resource. Example URLs: '/3', '/3/0', '/3/0/13'.\n In case of an update, the observation attributes are overwritten.\n Group identity must be a full group path.\n ## Usage example\n Provide path parameters: `groupId` - \"root.parent1.parent2.groupName\", `url` - \"/3/0/1\" and include the following request body:\n\n <br>\n\n ```\n {\n  \"minPeriod\": 45,\n  \"maxPeriod\": 60\n}\n ```\n",
        "operationId": "observations_createUpdateForGroupByUrl",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          },
          {
            "name": "url",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Lwm2mUrl"
            },
            "example": "/3/0/13"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GroupObservationRequest"
                  }
                ],
                "example": {"minPeriod":45,"maxPeriod":60}
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/protocolTests/report/device/{deviceId}": {
      "post": {
        "tags": [
          "DeviceTests"
        ],
        "description": "\n ## Overview\n Get report of the latest execution of tests on a device.\n ## Usage example\n Provide the device identity as the path parameter `deviceId` and use the following request body:\n\n <br>\n\n ```\n {\n  \"testCases\": [\n    \"testCase1\"                          ## Provide list of test cases to get a report of their execution\n  ]\n}\n ```\n",
        "operationId": "deviceTests_reportForDevice",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "testCases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "testCases"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestExecutionReport"
                }
              }
            }
          }
        }
      }
    },
    "/protocolTests/report/group/{groupId}": {
      "post": {
        "tags": [
          "DeviceTests"
        ],
        "description": "\n ## Overview\n Get report of the latest execution of tests on all devices in a group and its subgroups.\n ## Usage example\n Provide the group identity as the path parameter `groupId` and use the following request body:\n\n <br>\n\n ```\n {\n  \"testCases\": [\n    \"testCase1\"                          ## Provide list of test cases to get a report of their execution\n  ]\n}\n ```\n",
        "operationId": "deviceTests_reportForGroup",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "testCases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "testCases"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/TestExecutionReport"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/protocolTests/schedule/device/{device}": {
      "post": {
        "tags": [
          "DeviceTests"
        ],
        "description": "\n ## Overview\n Schedule tests on a device.\n ## Usage example\n Provide the device identity as the path parameter `device` and use the following request body:\n\n <br>\n\n ```\n {\n  \"testCases\": [\n    \"testCase1\"                          ## Provide list of test cases to schedule their execution\n  ]\n}\n ```\n",
        "operationId": "deviceTests_scheduleForDevice",
        "parameters": [
          {
            "name": "device",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "testCases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "testCases"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/protocolTests/schedule/group/{group}": {
      "post": {
        "tags": [
          "DeviceTests"
        ],
        "description": "\n ## Overview\n Schedule tests on all devices in a group and its subgroups.\n ## Usage example\n Provide the group identity as the path parameter `group` and use the following request body:\n\n <br>\n\n ```\n {\n  \"testCases\": [\n    \"testCase1\"                          ## Provide list of test cases to schedule their execution\n  ]\n}\n ```\n",
        "operationId": "deviceTests_scheduleForGroup",
        "parameters": [
          {
            "name": "group",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "testCases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "testCases"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/resources": {
      "post": {
        "tags": [
          "Resources"
        ],
        "description": "\n ## Overview\n  Create resource instance into which you can later upload data.\n\n ## Additional information\n  The \"location\" parameter describes the future location of the content of the resource instance:\n\n   - if you want to upload a file to the platform, use the format:\n\n<br>\n\n          {\"InternalLocation\": {\"fileName\": \"...\"}}\n<br>\n - if you want to upload a file to the platform and create a static url, use:\n\n<br>\n\n          {\"InternalLocation\": {\"fileName\": \"...\", \"staticContent\": true}}\n<br>\n - if the file is on an external server, use:\n\n<br>\n\n          {\"ExternalLocation\": {\"fileUrl\": \"url://...\"}}\n<br>\n - if the file is on an external server and the external server needs authentication credentials, use:\n\n<br>\n\n          {\"ExternalLocation\": {\"fileUrl\": \"url://...\", \"username\": \"...\", \"password\": \"...\"}}\n<br>\n If \"staticContent\" is set to true, static url will be generated and returned in response.\n\n<br>\n\n Available values for \"expirationTime\" parameter: `ONE_DAY`, `ONE_WEEK`, `ONE_MONTH`, `FOREVER`\n\n <br>\n\n Available values for \"category\" parameter: 'device-logs', 'datamodel', 'software', 'birt', 'device-r', 'privacy-policy', 'panel',\n      'cookie-policy', 'config', 'static-documentation', 'firmware', 'config backup', 'unknown', 'image', 'reports'.\n\n ## Usage example\n To create a resource instance for a future firmware file that will expire in one day and will be stored as internal file, use the following request body:\n```\n{\n  \"name\": \"exampleResourceName\",                                           ## decide what the resource name will be\n  \"description\": \"exampleDescription\",                                     ## decide what the resource description will be\n  \"location\": {\"InternalLocation\": {\"fileName\": \"exampleFileName}},        ## decide what should be the location of created resource\n  \"category\": \"FIRMWARE\",                                                  ## decide what the category will be\n  \"device\": \"exampleDeviceName\",                                           ## decide which device wil have access to resource\n  \"domain\": \"/exampleDomain/\",                                             ## decide which domain resource will land to\n  \"directGroups\": [\n    {\n      \"RawDirectGroup\": \"root.mt.exampleDomain\"                            ## decide which devices from which group will have access to resource\n    }\n  ],\n  \"expirationTime\": \"ONE_DAY\",                                             ## device what will the expiration time be\n  \"visibleForSubtenants\": false                                            ## decide if resource instance will be visible for subtenants\n}\n```\n",
        "operationId": "resources_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileResource"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileResourceAddResult"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/resources/{id}/data": {
      "put": {
        "tags": [
          "Resources"
        ],
        "description": "\n ## Overview\n Upload resource data into an existing resource instance.\n ## Additional information\n You must provide resource identity as the path parameter `id`. Specify a header `Content-Type application/octet-stream` and include the path to the file you want to upload. \n",
        "operationId": "resources_upload",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FileResourceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/resources/{id}/downloadUrl": {
      "post": {
        "tags": [
          "Resources"
        ],
        "description": "\n ## Overview\n Obtain a secure download URL to an existing resource.\n ## Additional information\n      You must provide resource identity as the path parameter `id`.\n\n <br>\n Specify the protocol to be used in the request body.\n Accepted protocols: HTTP, HTTPS, COAP, COAPS.\n ## Usage example\n ### To upload resource data into existing resource instance provide the identity of an existing resource instance as the path parameter and use the following body:\n\n <br>\n\n ```\n{\n  \"protocol\": \"HTTPS\"                             ## decide what protocol should the created URL use\n}\n ```\n",
        "operationId": "resources_createDownloadUrl",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FileResourceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDownloadUrlOptions"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceDownloadData"
                }
              }
            }
          }
        }
      }
    },
    "/sessions/{deviceId}": {
      "post": {
        "tags": [
          "Sessions"
        ],
        "description": "\n ## Overview\n Start a provisioning session with a selected device.\n ## Additional information\n      You must provide device identity as the path parameter `deviceId`. Optionally, you can provide the query parameter `taskId` if you want a specific task to be executed during the session.\n ## Usage example\n ### To start a session with a selected device, provide the identity of the device as the path parameter and optionally the identity of the task to be executed during the triggered session as the query parameter `taskId`.\n",
        "operationId": "sessions_startNewSession",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "taskId",
            "in": "query",
            "description": "If provided then a specific task will be executed during triggered session.",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/sessions/{deviceId}/allow-deregistered": {
      "post": {
        "tags": [
          "Sessions"
        ],
        "description": "\n ## Overview\n Start a provisioning session with a selected device, even if the device is not registered.\n ## Additional information\n      You must provide device identity as `deviceId`, Optionally, you can provide the query parameter `taskId` if you want a specific task to be executed during this session.\n ## Usage example\n ### To start a session with a selected device even if it's not registered, provide the identity of the device as the path parameter and optionally the identity of the task to be executed during the triggered session as the query parameter `taskId`.\n",
        "operationId": "sessions_startNewSessionAllowDeregistered",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "taskId",
            "in": "query",
            "description": "If provided then a specific task will be executed during triggered session.",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/settingValues": {
      "get": {
        "tags": [
          "SettingValues"
        ],
        "description": "\n ## Overview\n Get setting values using search criteria.\n ## Additional information\n For detailed instruction on search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving setting values with different criteria:\n <br>\n To get all setting values **do not use any criteria**\n\n <br>\n\n To get setting values, with _value_ equal to 'true', use:\n\n\n ```\n value eq 'true'\n ```\n\n <br>\n\n To get setting values with _name_ equal to 'disableUnavailableNocAlert', use:\n\n\n ```\n name eq 'disableUnavailableNocAlert'\n ```\n\n <br>\n\n To get setting values with combined criteria, use:\n\n\n ```\n value eq 'true', name eq 'true'\n ```\n",
        "operationId": "settingValues_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **groupId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **value** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SettingValueQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SettingValueDTO"
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "SettingValues"
        ],
        "description": "\n ## Overview\n Create or update a setting value.\n ## Additional information\n Setting Values can be applied to groups and domains represented as groups.\n ## Usage example\n Use the following request body:\n ```\n {\n  \"groupId\": \"root.mt.exampleGroup\",                   ## provide group id, it can be a domain group as well\n  \"name\": \"exampleSettingValueName\",                   ## provide setting value key\n  \"value\": \"exampleValue\",                             ## provide value\n  \"isSecret\": false                                    ## decide if value should be hidden\n}\n```\n",
        "operationId": "settingValues_createOrUpdate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SettingValueDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/settingValues/deviceProfile/{deviceId}": {
      "get": {
        "tags": [
          "SettingValues"
        ],
        "description": "\n ## Overview\n Get the setting values profile for a given device.\n\n <br>\n Setting Values Profile consists of setting values inherited from all groups the device belongs to.\n ## Additional information\n You must provide device identity as the path parameter `deviceId`.\n There is also an optional boolean query parameter `withDeviceProperties`. If set to \"true\" the profile is returned with the device properties.\n ## Usage example\n Provide the device identity as the path parameter `deviceId` and the optional query parameter `withDeviceProperties` with the value \"true\" to obtain given device profile with device properties.\n",
        "operationId": "settingValues_getForDevice",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "withDeviceProperties",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SettingValueDTO"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/settingValues/groupProfile/{groupId}": {
      "get": {
        "tags": [
          "SettingValues"
        ],
        "description": "\n ## Overview\n Get the setting values profile for a given group.\n ## Additional information\n You must provide group identity as the path parameter `groupId`.\n The group identity must be a full path, for example root.mt.exampleGroup.\n",
        "operationId": "settingValues_getForGroup",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SettingValueDTO"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/taskReports": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get task reports using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving task reports with different criteria:\n <br>\n To get all task reports **do not use any criteria**.\n\n <br>\n\n To get task reports with _deviceId_ 'example', use:\n\n\n ```\n deviceId eq 'example'\n ```\n\n <br>\n\n To get task reports for which _summary_ exists, use:\n\n\n ```\n summary exists\n ```\n\n <br>\n\n To get task reports with combined criteria, use:\n\n\n ```\n deviceId eq 'example', summary exists\n ```\n",
        "operationId": "taskReports_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **taskId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **deviceId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **startTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **finishTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastUpdateTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **status** (#/components/schemas/TaskStatus) : eq, ne, in, nin, exists, notexists\n- **summary** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TaskReportQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TaskReportId"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/taskReports/findReports": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get cursor for task reports using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving cursor for task reports with different criteria:\n To get cursor for all task reports **do not use any criteria**.\n\n <br>\n\n To get cursor for task reports of device with _id_ equal to 'example', use:\n\n\n ```\n deviceId eq 'example'\n ```\n\n <br>\n\n To get cursor for task reports for which _summary_ exist, use:\n\n\n ```\n summary exists\n ```\n\n <br>\n\n To get cursor for task reports with combined criteria, use:\n\n\n ```\n deviceId eq 'example', summary exists\n ```\n",
        "operationId": "taskReports_taskReportCursor",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **taskId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **deviceId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **startTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **finishTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastUpdateTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **status** (#/components/schemas/TaskStatus) : eq, ne, in, nin, exists, notexists\n- **summary** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TaskReportQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskReportCursor"
                }
              }
            }
          }
        }
      }
    },
    "/taskReports/findSince": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get task reports since a given time (inclusive).\n ## Additional information\n List of Task Reports is ordered by a tuple ('lastUpdateTime', 'taskId', 'deviceId').\n You must provide the query parameter `lastUpdateTime`. \n When there is more than one report with the 'lastUpdateTime' equal to a given time, and you provide 'taskId' and 'deviceId, they will point to the first report after which results are fetched.  \n You can also provide the parameter 'pollingInterval' to limit the period after 'lastUpdateTime'. If you set 'pollingInterval' only task reports updated between 'lastUpdateTime' and 'lastUpdateTime' plus 'pollingInterval' will be returned.\n \n <br>\n\n Example use case - paging:\n 1. You retrieve TaskReports since a specific lastUpdateTime and don't provide the values of 'taskId' and 'deviceId'.\n Result: You get TaskReports with `lastUpdateTime` greater or equal to the provided value (sorted by 'lastUpdateTime' and 'TaskReportId').\n 2. You want to retrieve the second page of TasksReports - you need to use specific parameters:\n  - 'lastUpdateTime' - use corresponding value of the last retrieved element from the previous execution\n  - 'taskId', 'deviceId' - use corresponding values ('taskId', 'deviceId') from the last retrieved element of the previous execution. \n The request returns the TaskReports updated since the provided 'lastUpdateTime' without repeating the last element (exclusion).\n ## Usage example\n Provide the required query parameter `lastUpdateTime` - \"2022-12-01T08:05:35Z\" and optional `taskId` - \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1\",\n `deviceId` - \"test-device-id\", `limit` - \"1000\", `pollingInterval` - \"86400\" and `directTasksOnly` - \"true\".\n\n You can find default values for the optional parameters in the parameters section.\n",
        "operationId": "taskReports_findSince",
        "parameters": [
          {
            "name": "lastUpdateTime",
            "in": "query",
            "description": "The format supported for 'lastUpdateTime' is: 'yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "required": true,
            "explode": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "taskId",
            "in": "query",
            "description": "'taskId' used alongside 'deviceId' to order by TaskReportId. If used, 'deviceId' must also be provided.",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          },
          {
            "name": "deviceId",
            "in": "query",
            "description": "'deviceId' used alongside 'taskId' to order by TaskReportId. If used, 'taskId' must also be provided.",
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Specifies how many records are retrieved. Must be greater than 0. Default value is 512",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 512
            }
          },
          {
            "name": "pollingInterval",
            "in": "query",
            "description": "Specifies time interval in seconds since 'lastUpdateTime' from which taskReports should be returned. If not specified then there is no limit",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "directTasksOnly",
            "in": "query",
            "description": "Specifies whether only the tasks scheduled directly on the device should be included while group tasks should be omitted. By default, the value is set to 'false'",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TaskReportDTO"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/taskReports/moreReports": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get next task report batch for cursor value obtained from\n GET on `/taskReports/findReports` or previous GET on `/taskReports/moreReports`.\n ## Additional information\n You have to provide a cursor integer as the query parameter `cursor`. Optionally, you can provide also an integer count as the query parameter `count`.\n",
        "operationId": "taskReports_getMoreReports",
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": true,
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/TaskReportCursor"
            }
          },
          {
            "name": "count",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 512
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskReportBatch"
                }
              }
            }
          }
        }
      }
    },
    "/taskReports/summary": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get a summary of task execution.\n ## Additional information\n You must provide task identity as the query parameter `taskId`.\n The response body includes:\n- totalScheduled - the number of devices on which the task was scheduled,\n- inProgress - the number of devices on which the task is still in progress,\n- completed - the number of devices on which the task completed,\n- successes - the number of devices on which the task completed successfully,\n- failures - the number of devices on which the task failed,\n- notCompleted - the number of devices on which the task has not been completed (includes in progress and not started),\n- completionRate - total completion rate number (ratio of completed/total number of devices, where completed includes both success and failure),\n- successRate - success rate\n- failureRate - failure rate\n",
        "operationId": "taskReports_summary",
        "parameters": [
          {
            "name": "taskId",
            "in": "query",
            "required": true,
            "explode": false,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskReportsSummary"
                }
              }
            }
          }
        }
      }
    },
    "/taskReports/{taskId}/{deviceId}": {
      "get": {
        "tags": [
          "TaskReports"
        ],
        "description": "\n ## Overview\n Get task reports for a given task and device.\n ## Additional information\n You must provide device identity as the path parameter `deviceId` and task identity as the path parameter`taskId`.\n You can only get the task report after the task has been performed on the device.\n <br>\n Possible custom error codes in the response body:\n\n**4040**: Task was not found.\n\n**4041**: Task was not executed yet.\n\n",
        "operationId": "taskReports_get",
        "parameters": [
          {
            "name": "taskId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          },
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorMessageWithOptCode"
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskReportDTO"
                }
              }
            }
          }
        }
      }
    },
    "/tasks": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Get task entities using search criteria.\n ## Additional information\n For detailed information about search criteria, available operators and values, see the parameters section.\n ## Usage example\n ### Retrieving task entities with different criteria:\n <br>\n To get all task entities **do not use any criteria**.\n\n <br>\n\n To get active task entities, use:\n\n\n ```\n active eq 'true'\n ```\n\n <br>\n\n To get task entities for device with _id_ containing 'example' string, use:\n\n\n ```\n id strcontains 'example'\n ```\n <br>\n\n To get task entities with combined criteria, use:\n\n\n ```\n active eq 'true', id strcontains 'example'\n ```\n",
        "operationId": "tasks_find",
        "parameters": [
          {
            "name": "searchCriteria",
            "in": "query",
            "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **device** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **active** (boolean) : eq\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TaskQuery"
                }
              ],
              "default": ""
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TaskId"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/tasks/callback/{taskId}/{callbackName}": {
      "delete": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Method enables deleting callback registered on a given task identity.\n ## Additional information\n You must provide task identity as the path parameter `taskId` and the callback name to delete as the path parameter `callbackName`.\n",
        "operationId": "tasks_deleteCallback",
        "parameters": [
          {
            "name": "taskId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          },
          {
            "name": "callbackName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/tasks/configure/{deviceId}": {
      "post": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Create a device configuration task from JSON and apply it for a device.\n ## Additional information\n The commands execute in the order specified by the request\n unless the `batchRequests` flag is set to `true`. In that case the requests to device are batched.<br>\n If a request fails, then the remaining requests are not executed.<br>\n If the `executeImmediately` flag is set, then the task is executed immediately for a registered device.\n Otherwise, the server waits until the device connects.<br>\n It is possible to provide custom task name using the optional `name` field.<br>\n ## Usage example\n Provide device identity as the path parameter `deviceId` and include the request body.\n The following is an example of the request body. \n Note: `LwM2M Server` instance numbers might vary. The following instance numbers are just an example.\n\n <br>\n\n ```\n{\n  \"taskDefinition\": {\n    \"operations\": [\n      {\n        \"read\": {\n          \"key\": \"Device.0.Current Time\"\n        }\n      },\n      {\n        \"write\": {\n          \"key\": \"LwM2M Server.1.Lifetime\",\n          \"value\": \"12345\"\n        }\n      },\n      {\n        \"execute\": {\n          \"key\": \"LwM2M Server.1.Registration Update Trigger\"\n        }\n      }\n    ],\n    \"name\" : \"Custom task name\"\n  }\n}\n```\n\n <br>\n\n The arguments to the `execute` command are optional. An argument can be a single decimal digit,\n or a digit and a string. Example:\n\n <br>\n\n```\n{\n  \"execute\": {\n    \"key\": \"Example.2.Arguments\",\n    \"argumentList\": [{\"digit\": \"7\"}, {\"digit\": \"1\", \"argument\": \"hello\"}]\n  }\n}\n```\n\n <br>\n\n The TaskReport of the task created via this endpoint can have the following properties:\n\n - 'lastSuccessfulOperation' - last successfully performed requests (can be used to identify failing request).\n This property is absent if the `batchRequests` flag is set to `true`.\n\n  - '`write.key`' (as provided by the command) - result of each `write` command.\n If multiple `write` commands are executed for a single key,\n then the most recent one overwrites the earlier.\n",
        "operationId": "tasks_configureDevice",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "taskDefinition": {
                    "$ref": "#/components/schemas/ConfigurationTaskDefinition"
                  }
                },
                "required": [
                  "taskDefinition"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/tasks/firmwareUpdate/multicomponent/{deviceId}": {
      "post": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Create a multicomponent FOTA task supported by AVSystem Anjay from existing FOTA configuration and apply it for a device.\n ## Additional information\n The response body contains the `taskId`. You can use `GET /taskReports/{taskId}/{deviceId}` with the obtained taskId to track task progress.\n\n<br>\n\n ## Usage example\n Provide the path parameter `deviceId` and optional query parameter: `executeImmediately`.\n Remember to include request body with `fotaConfigId`\n The following is an example of the request body:\n <br>\n\n```JSON\n{\n  \"fotaConfigId\": \"64de3e28a5e13a61ab0f1621\",\n}\n```\n\n <br>\n You can obtain the argument `fotaConfigId` after the successful creation of the fotaConfiguration or by listing the already existing configurations.\n <br>\n\n<br>\n",
        "operationId": "tasks_createMulticomponentFota",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "executeImmediately",
            "in": "query",
            "description": "If set to true then session is started after creating the task.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "fotaConfigId": {
                    "$ref": "#/components/schemas/FirmwareUpdateConfigurationId"
                  }
                },
                "required": [
                  "fotaConfigId"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/tasks/upgrade/{deviceId}/{fileResourceId}": {
      "post": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Create a device firmware upgrade (FOTA) task from given parameters and apply it for a device.\n ## Additional information\nThe response body contains the `taskId`. You can use `GET /taskReports/{taskId}/{deviceId}` with the obtained taskId to track task progress.\n**Note:** If you haven't created any file resource yet you can use `POST /resources` to do it.\n\n**Note:** If you need more control over the task execution (for example, schedule it for a group or have a callback when the task is done)\n you can use `/taskFromTemplates`.\n\n<br>\n\n ## Usage example\nProvide the path parameters `deviceId` - \"test-device-id\", `fileResourceId` - \"\"\nand optional query parameters: `transferMethod` - \"push\", `transferProtocol` - \"coap\", `timeout` - \"1h\", `useQuota` - \"false\",\n`upgradeStrategy` - \"ObservationBased\", `blocking` - \"true\", `useCacheForInitialStateRead` - \"true\", `checkDeliveryAndProtocol` - \"true\", `resumeAfterDownlinkFailure` - \"true\" and `executeImmediately` - \"true\". Include a request body with the task template name and configuration. \n\nAvailable values and defaults for all optional parameters are listed in the parameters section.\n\n<br>\n\nThis API call (with default settings) is equivalent to a more complicated but also more power full call:\n`POST /tasksFromTemplates/device/{deviceId}`\n\n<br>\nAn example of the request body:\n\n```JSON\n{\n  \"templateName\": \"apiUpgradeTemplate\",\n  \"config\": {\n    \"taskName\": \"LwM2MFirmwareManagement\",\n    \"parameters\": [\n      { \"name\": \"resourceId\", \"value\": \"{fileResourceId}\" },\n      { \"name\": \"transferMethod\", \"value\": \"{transferMethod}\" },\n      { \"name\": \"transferProtocol\", \"value\": \"{transferProtocol}\" },\n      { \"name\": \"timeoutSec\", \"value\": \"{timeout-converted-to-seconds}\" },\n      { \"name\": \"useQuota\", \"value\": \"{useQuota}\" },\n      { \"name\": \"strategy\", \"value\": \"{strategy}\" },\n      { \"name\": \"blocking\", \"value\": \"{blocking}\" },\n      { \"name\": \"useCacheForInitialStateRead\", \"value\": \"{useCacheForInitialStateRead}\" },\n      { \"name\": \"checkDeliveryAndProtocol\", \"value\": \"{checkDeliveryAndProtocol}\" }\n    ],\n    \"properties\": {\n       \"TaskProp_Action\": \"upgrade\",\n       \"TaskProp_ActionTargetResource\": \"<file-id>\"\n    }\n  }\n}\n```\n\n<br>\n\nYou can also use `group` or `deviceBlocking` version.\nWhen using `POST /tasksFromTemplates` timeout must be provided as a plain number of seconds (e.g. `1200`)\n    ",
        "operationId": "tasks_upgradeDevice",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "fileResourceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FileResourceId"
            }
          },
          {
            "name": "transferMethod",
            "in": "query",
            "description": "`Pull` - the device will download firmware on its own.\n\n`Push` - firmware will be sent as inbound CoAP block message.\n\nUsually `Pull` is recommended. `Push` might perform better for small firmware files.\nMeaning of 'small' depends on the network quality and devices capabilities.",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TransferMode"
                }
              ],
              "default": "Pull"
            }
          },
          {
            "name": "transferProtocol",
            "in": "query",
            "description": "Protocol used for downloading firmware file - used only in `Pull` transfer mode.\nSome devices might not support all possible protocols.\n      ",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TransferProtocol"
                }
              ],
              "default": "HTTP"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Timeout of firmware upgrade. Time with unit or number of seconds: e.g (`1h 20m`, `300s` or `30`).",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TimeSpan"
                }
              ],
              "default": "20m"
            }
          },
          {
            "name": "useQuota",
            "in": "query",
            "description": "Whether to use quota - throttling mechanism. Useful to protect against network congestion.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "upgradeStrategy",
            "in": "query",
            "description": "`WithoutObservations` - Do not use observations while upgrading.\n\n`ObservationTrigger` - Use observations to trigger upgrade.\n\n`ObservationBased` - Use observations to optimize upgrade.\n\n`SendBased` - Use send mechanism instead of observations.\n\nYou can find more information about strategies in the system documentation",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/UpgradeStrategy"
                }
              ],
              "default": "WithoutObservations"
            }
          },
          {
            "name": "blocking",
            "in": "query",
            "description": "Disallow execution of any other tasks during the upgrade. Disable only when you are sure it is necessary.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "useCacheForInitialStateRead",
            "in": "query",
            "description": "Uses cached data model for reading the initial state. If the cached data model is empty, standard data model is checked as a fallback.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "checkDeliveryAndProtocol",
            "in": "query",
            "description": "Whether to check if delivery method and transfer protocol are selected before the actual FOTA starts.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "resumeAfterDownlinkFailure",
            "in": "query",
            "description": "Firmware upgrade resumes execution upon new contact with the device if it stopped in the last communication due to a downlink failure.\nThe place it stopped before is used as a starting point, so it begins with retry of the last unsuccessful action.\n",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "useObservation",
            "in": "query",
            "description": "Obsolete, not used.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "extendLifetime",
            "in": "query",
            "description": "Obsolete, not used.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "executeImmediately",
            "in": "query",
            "description": "If set to true then session is started after creating the task.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/tasks/{id}": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Get a task by its identity.\n ## Additional information\n You must provide task identity as the path parameter `id`.\n",
        "operationId": "tasks_get",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Update a task entity.\n ## Usage example\n Provide task identity as the path parameter `id` and use the following request body:\n\n <br>\n\n ```\n {\n  \"taskName\": \"string\",                    ## Provide new task name\n  \"parameters\": [                          ## Provide new task parameters if any\n    {\n      \"name\": \"string\",\n      \"value\": \"string\"\n    }\n  ],\n  \"isActive\": true,                        ## Device if task is active\n  \"properties\": {\n    \"additionalProp1\": \"string\"            ## Provide additional properties if any\n  }\n}\n ```\n",
        "operationId": "tasks_update",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TaskConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tasks"
        ],
        "description": "\n ## Overview\n Delete a task entity.\n ## Additional information\n You must provide task identity as the path parameter `id`.\n",
        "operationId": "tasks_delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TaskId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    },
    "/tasksFromTemplates/device/{deviceId}": {
      "post": {
        "tags": [
          "TasksFromTemplates"
        ],
        "description": "\n ## Overview\n Create task that will be executed on the device with a given identity.\n ## Additional information\n Task definition will be copied from the task template with a given name.\n The values from template fields can be overwritten in a given TaskConfig.\n\n The TaskReportDTO will be sent to the registered callback using HTTP POST each time the task finishes execution.\n The result of this is the identity of the created task. All fields in the request body are optional.\n## Usage example\nProvide full group identity as the path parameter `groupId` and use the following request body:\n\n <br>\n\n ```\n{\n  \"templateName\": \"string\",                        ## Provide template name\n  \"config\": {\n    \"taskName\": \"string\",                          ## Provide task name\n    \"parameters\": [                                ## Provide parameters if any\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ],\n    \"isActive\": true,                              ## Decide if created task will be active\n    \"properties\": {                                ## Provide additional properties if any\n      \"additionalProp1\": \"string\",\n      \"additionalProp2\": \"string\",\n      \"additionalProp3\": \"string\"\n    }\n  },\n  \"callback\": {                                    ## Provide callback uri if any\n    \"uri\": \"string\",\n    \"name\": \"string\"\n  }\n}\n```\n",
        "operationId": "tasksFromTemplates_addForDevice",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "executeImmediately",
            "in": "query",
            "description": "If set to true then a session starts after creating the task.",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TaskTemplateInvocation"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/tasksFromTemplates/deviceBlocking/{deviceId}": {
      "post": {
        "tags": [
          "TasksFromTemplates"
        ],
        "description": "\n ## Overview\n Create device blocking task that will be executed on the device with a given identity.\n ## Additional information\n Task definition will be copied from the task template with a given name.\n The values from template fields can be overwritten in a given TaskConfig.\n This method waits up to waitTimeSeconds for the task execution and returns TaskReport.\n If the task doesn't execute in a given time period the TaskReport with status \"NotStarted\" will be returned.\n The TaskReportDTO will be sent to the registered callback using HTTP POST each time the task finishes execution. All fields in the request body are optional.\n## Usage example\nProvide full group identity as the path parameter `groupId` and use the following request body:\n\n <br>\n\n ```\n{\n  \"templateName\": \"string\",                        ## Provide template name\n  \"config\": {\n    \"taskName\": \"string\",                          ## Provide task name\n    \"parameters\": [                                ## Provide parameters if any\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ],\n    \"isActive\": true,                              ## Decide if created task will be active\n    \"properties\": {                                ## Provide additional properties if any\n      \"additionalProp1\": \"string\",\n      \"additionalProp2\": \"string\",\n      \"additionalProp3\": \"string\"\n    }\n  },\n  \"callback\": {                                    ## Provide callback uri if any\n    \"uri\": \"string\",\n    \"name\": \"string\"\n  }\n}\n```\n",
        "operationId": "tasksFromTemplates_addForDeviceBlocking",
        "parameters": [
          {
            "name": "deviceId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DeviceId"
            }
          },
          {
            "name": "waitTimeSeconds",
            "in": "query",
            "description": "Time with unit or number of seconds: e.g (`1h 20m`, `300s` or `30`).",
            "explode": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TimeSpan"
                }
              ],
              "default": "30s"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TaskTemplateInvocation"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskReportDTO"
                }
              }
            }
          }
        }
      }
    },
    "/tasksFromTemplates/group/{groupId}": {
      "post": {
        "tags": [
          "TasksFromTemplates"
        ],
        "description": "\n ## Overview\n Create task that will be executed on the group with a given identity.\n Task definition will be copied from the task template with a given name.\n ## Additional information\n The values from template fields can be overwritten in a given TaskConfig.\n The TaskReportDTO will be sent to the registered callback using HTTP POST each time the task finishes execution on each device.\n The result of this method is the identity of the created task. All fields in the request body are optional.\n## Usage example\nProvide full group identity as the path parameter `groupId` and use the following request body:\n\n <br>\n\n ```\n{\n  \"templateName\": \"string\",                        ## Provide template name\n  \"config\": {\n    \"taskName\": \"string\",                          ## Provide task name\n    \"parameters\": [                                ## Provide parameters if any\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ],\n    \"isActive\": true,                              ## Decide if created task will be active\n    \"properties\": {                                ## Provide additional properties if any\n      \"additionalProp1\": \"string\",\n      \"additionalProp2\": \"string\",\n      \"additionalProp3\": \"string\"\n    }\n  },\n  \"callback\": {                                    ## Provide callback uri if any\n    \"uri\": \"string\",\n    \"name\": \"string\"\n  }\n}\n```\n",
        "operationId": "tasksFromTemplates_addForGroup",
        "parameters": [
          {
            "name": "groupId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/GroupId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TaskTemplateInvocation"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskId"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/users": {
      "post": {
        "tags": [
          "Users"
        ],
        "description": "\n ## Overview\n Create a standard user.\n ## Additional information\n You must specify the following parameters in the request body:\n\n- login - user's login\n\n- email - user's email\n\n- emailVerified - set true to create user with already verified email\n\n- domain - user's domain\n\n- password - user's password\n\n- roles - user's roles, leave empty if not willing to add any\n\n- permissions - user's permissions, leave empty if not willing to add any\n\n- tosAccepted - terms of service, set true to create user with already accepted Terms of Service\n\n ## Usage example\n Provide the following request body:\n\n <br>\n\n ```\n{\n  \"login\": \"string\",                       ## Provide user login\n  \"email\": \"string\",                       ## Provide user email\n  \"emailVerified\": true,                   ## Decide if user email should be already verified\n  \"domain\": \"/testDomain/\",                ## Provide user domain\n  \"password\": \"string\",                    ## Provide user password\n  \"roles\": [\n    \"string\"                               ## Provide user roles if any\n  ],\n  \"permissions\": [\n    \"string\"                               ## Provide user permissions if any\n  ],\n  \"tosAccepted\": true                      ## Decide if terms of service should be already accepted\n}\n ```\n",
        "operationId": "users_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IamUserDto"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "201": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/users/search/usernames": {
      "get": {
        "tags": [
          "Users"
        ],
        "description": "\n ## Overview\n Find users by username, email, domain, or activity.\n ## Additional information \n You can provide optional query parameters - `username`, `email`, `domain`, `isActiveOnly`.\n If you don't provide any parameters, all usernames will be return.\n",
        "operationId": "users_search",
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "email",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "domain",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "isActiveOnly",
            "in": "query",
            "explode": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserId"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/users/{username}": {
      "get": {
        "tags": [
          "Users"
        ],
        "description": "\n ## Overview\n Get user data by username.\n ## Additional information\n You must provide the username as the path parameter `username`.\n",
        "operationId": "users_get",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/UserId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserDto"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "description": "\n ## Overview\n Delete user by username.\n ## Additional information\n You must provide the username as the path parameter `username`.\n",
        "operationId": "users_remove",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/UserId"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Users"
        ],
        "description": "\n ## Overview\n Update user properties.\n ## Additional information\n You must provide the username as the path parameter `username` and include the properties you want to change in the request body.\n ## Usage example\n Provide the username as the path parameter. In the request body set the field \"userEnabled\" to \"true\" to enable the user:\n ```\n {\n \"userEnabled\":true\n }\n ```\n",
        "operationId": "users_patch",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/UserId"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IamUserPatchDto"
              }
            }
          },
          "required": true
        },
        "responses": {
          "404": {
            "description": "entity not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "429": {
            "description": "too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "request forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "service unavailable",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "conflict with server state",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "bad request",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Successful"
                }
              }
            }
          }
        }
      }
    }
  },
  "servers": [
    {
      "url": "https://eu.iot.avsystem.cloud/api/coiotedm/v3"
    }
  ],
  "components": {
    "schemas": {
      "AssignedPropertiesGet": {
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string"
          },
          "creationTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "target": {
            "$ref": "#/components/schemas/AssignedPropertiesTarget"
          },
          "isActive": {
            "type": "boolean"
          },
          "wasApplied": {
            "type": "boolean"
          },
          "lastApplication": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "multiShot": {
            "type": "boolean"
          },
          "lastMatchedDevice": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DeviceId"
              }
            ]
          }
        },
        "required": [
          "externalId",
          "creationTime",
          "target",
          "isActive",
          "wasApplied",
          "lastApplication",
          "properties",
          "multiShot",
          "lastMatchedDevice"
        ]
      },
      "AssignedPropertiesPatch": {
        "type": "object",
        "properties": {
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "putProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "removeProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          },
          "multiShot": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "reapply": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "AssignedPropertiesPut": {
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/AssignedPropertiesTarget"
          },
          "isActive": {
            "type": "boolean",
            "default": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "multiShot": {
            "type": "boolean",
            "default": true
          }
        },
        "required": [
          "target",
          "properties"
        ]
      },
      "AssignedPropertiesQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **externalId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **target** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **lastMatchedDevice** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "AssignedPropertiesTarget": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ]
      },
      "AttributesVector": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ObservationAttribute"
        }
      },
      "AwsExternalCertificateRequest": {
        "type": "object",
        "properties": {
          "certificatePem": {
            "type": "string"
          },
          "privateKey": {
            "type": "string"
          }
        },
        "required": [
          "certificatePem",
          "privateKey"
        ]
      },
      "AzureDpsExtensionConfig": {
        "type": "object",
        "properties": {
          "scopeId": {
            "type": "string"
          },
          "enrollmentGroupSymmetricKey": {
            "type": "string"
          },
          "dpsEndpoint": {
            "type": "string",
            "default": "global.azure-devices-provisioning.net"
          }
        },
        "required": [
          "scopeId",
          "enrollmentGroupSymmetricKey"
        ]
      },
      "AzureIotCentralExtensionConfig": {
        "type": "object",
        "properties": {
          "apiToken": {
            "type": "string"
          },
          "iotCentralHost": {
            "type": "string"
          },
          "dpsHost": {
            "type": "string"
          },
          "syncEnabled": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "apiToken",
          "iotCentralHost"
        ]
      },
      "AzureIotHubExtensionConfig": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string"
          },
          "storageConnectionString": {
            "type": "string"
          },
          "syncEnabled": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "connectionString",
          "storageConnectionString"
        ]
      },
      "Basic": {
        "type": "object",
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "Basic"
            ]
          },
          "resourceId": {
            "$ref": "#/components/schemas/FileResourceId"
          },
          "transfer": {
            "$ref": "#/components/schemas/FirmwareUpdateTransferConfiguration"
          },
          "timeout": {
            "$ref": "#/components/schemas/TimeSpan"
          }
        },
        "required": [
          "kind",
          "resourceId",
          "transfer",
          "timeout"
        ]
      },
      "BasicDomainPropertiesDTO": {
        "type": "object"
      },
      "BinaryPsk": {
        "type": "array",
        "items": {
          "type": "integer",
          "format": "int32",
          "maximum": 127,
          "minimum": -128
        }
      },
      "ComponentInstanceId": {
        "type": "integer",
        "format": "int32",
        "title": "Lwm2mComponentInstanceId"
      },
      "ConfigurationOperation": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "read": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  }
                },
                "required": [
                  "key"
                ]
              }
            },
            "required": [
              "read"
            ]
          },
          {
            "type": "object",
            "properties": {
              "write": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                },
                "required": [
                  "key",
                  "value"
                ]
              }
            },
            "required": [
              "write"
            ]
          },
          {
            "type": "object",
            "properties": {
              "execute": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "argumentList": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/ExecuteArgumentList"
                      }
                    ],
                    "default": []
                  }
                },
                "required": [
                  "key"
                ]
              }
            },
            "required": [
              "execute"
            ]
          }
        ]
      },
      "ConfigurationTaskDefinition": {
        "type": "object",
        "properties": {
          "operations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfigurationOperation"
            }
          },
          "name": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "batchRequests": {
            "type": "boolean",
            "default": false
          },
          "executeImmediately": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "operations"
        ]
      },
      "ConnectorType": {
        "type": "string",
        "enum": [
          "management",
          "bootstrap"
        ]
      },
      "ConsoleServerUrl": {
        "type": "string"
      },
      "CreateDownloadUrlOptions": {
        "type": "object",
        "properties": {
          "protocol": {
            "type": "string",
            "enum": [
              "HTTP",
              "HTTPS",
              "COAP",
              "COAPS",
              "COAP_TCP",
              "COAP_TLS"
            ]
          }
        },
        "required": [
          "protocol"
        ]
      },
      "DataModelParameter": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "updateTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "name",
          "value",
          "type",
          "updateTime"
        ]
      },
      "DeviceBatchAddSingleResult": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DeviceId"
          },
          "success": {
            "type": "boolean"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "id",
          "success"
        ]
      },
      "DeviceBatchAppResponse": {
        "type": "object",
        "properties": {
          "total": {
            "type": "integer",
            "format": "int32"
          },
          "succeeded": {
            "type": "integer",
            "format": "int32"
          },
          "failed": {
            "type": "integer",
            "format": "int32"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeviceBatchAddSingleResult"
            }
          }
        },
        "required": [
          "total",
          "succeeded",
          "failed",
          "results"
        ]
      },
      "DeviceDTO": {
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DeviceId"
              }
            ]
          },
          "connectorType": {
            "$ref": "#/components/schemas/ConnectorType"
          },
          "directGroups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "blacklisted": {
            "type": "boolean",
            "default": false
          },
          "managementEnabled": {
            "type": "boolean",
            "default": true
          },
          "lastSessionTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "lastContactTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "lastRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "firstRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "creationTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "ipAddress": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "serialNumber": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "oui": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "modelName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "hardwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "softwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "productClass": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "manufacturer": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "friendlyName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "domain": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DomainId"
              }
            ],
            "default": null
          },
          "securityMode": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityMode"
              }
            ],
            "default": null
          },
          "dtlsIdentity": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "dtlsPsk": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/FormattedPsk"
              }
            ],
            "default": null
          }
        },
        "required": [
          "id",
          "connectorType"
        ]
      },
      "DeviceDetails": {
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DeviceId"
              }
            ],
            "default": null
          },
          "connectorType": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ConnectorType"
              }
            ],
            "default": null
          },
          "directGroups": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": null
          },
          "properties": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "default": null
          },
          "blacklisted": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "managementEnabled": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "lastSessionTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "lastContactTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "lastRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "firstRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "creationTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "ipAddress": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "serialNumber": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "oui": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "modelName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "hardwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "softwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "productClass": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "manufacturer": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "friendlyName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "domain": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DomainId"
              }
            ],
            "default": null
          },
          "securityMode": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityMode"
              }
            ],
            "default": null
          },
          "dtlsIdentity": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "dtlsPsk": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/FormattedPsk"
              }
            ],
            "default": null
          }
        }
      },
      "DeviceDirectGroup": {
        "type": "object",
        "properties": {
          "manufacturer": {
            "type": "string"
          },
          "model": {
            "type": "string"
          },
          "version": {
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "manufacturer",
          "model",
          "version"
        ]
      },
      "DeviceEventsHandler": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/taggedkafka"
          },
          {
            "$ref": "#/components/schemas/taggedwebhook"
          }
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "kafka": "#/components/schemas/taggedkafka",
            "webhook": "#/components/schemas/taggedwebhook"
          }
        }
      },
      "DeviceField": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma separated list of fields.\n\n ## Available fields:\n  - **id**\n- **bootstrap**\n- **connectorType**\n- **blacklisted**\n- **managementEnabled**\n- **lastSessionTime**\n- **lastContactTime**\n- **lastRegisterTime**\n- **firstRegisterTime**\n- **creationTime**\n- **ipAddress**\n- **serialNumber**\n- **oui**\n- **modelName**\n- **hardwareVersion**\n- **softwareVersion**\n- **productClass**\n- **manufacturer**\n- **description**\n- **friendlyName**\n- **domain**\n- **securityMode**\n- **directGroups**\n- **groups**\n- **properties**\n- **dtlsIdentity**\n- **dtlsPsk**\n\n ## Examples:\n - *id*\n - *id, modelName, domain*\n - *id, description*\n "
      },
      "DeviceId": {
        "type": "string"
      },
      "DeviceKafkaEventsHandlerCreateData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/KafkaConnectionConfig"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "enabled",
          "connectionConfig",
          "filter"
        ]
      },
      "DeviceKafkaEventsHandlerUpdateData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/KafkaConnectionConfig"
          },
          "description": {
            "type": "string"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          }
        }
      },
      "DeviceQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **bootstrap** (boolean) : eq\n- **connectorType** (#/components/schemas/ConnectorType) : eq, ne, in, nin, exists, notexists\n- **blacklisted** (boolean) : eq\n- **managementEnabled** (boolean) : eq\n- **lastSessionTime** (string($date-time)) Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastContactTime** (string($date-time)) Time of the last successful network communication with a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastRegisterTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **firstRegisterTime** (string($date-time)) Time of the first successful register request from a device: eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **ipAddress** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **serialNumber** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **oui** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **modelName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **hardwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **softwareVersion** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **productClass** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **manufacturer** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **friendlyName** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **domain** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **securityMode** (#/components/schemas/SecurityMode) : eq, ne, in, nin, exists, notexists\n- **directGroups** ([string]) : contains, notcontains, containsany\n- **groups** ([string]) : contains, notcontains, containsany\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "DeviceUpdate": {
        "type": "object",
        "properties": {
          "addProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "removeProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "addGroups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "removeGroups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "blacklisted": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "managementEnabled": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "lastSessionTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "lastRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "firstRegisterTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "creationTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "default": null
          },
          "ipAddress": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "serialNumber": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "oui": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "modelName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "hardwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "softwareVersion": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "productClass": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "manufacturer": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "friendlyName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "domain": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "securityMode": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityMode"
              }
            ],
            "default": null
          },
          "dtlsIdentity": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "dtlsPsk": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/FormattedPsk"
              }
            ],
            "default": null
          }
        }
      },
      "DeviceWebhookEventsHandlerCreateData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/WebhookConnectionConfig"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "enabled",
          "connectionConfig",
          "filter"
        ]
      },
      "DeviceWebhookEventsHandlerUpdateData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/WebhookConnectionConfig"
          },
          "description": {
            "type": "string"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          }
        }
      },
      "DevicesDetailsPage": {
        "type": "object",
        "properties": {
          "devices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeviceDetails"
            }
          },
          "nextPageBookmark": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/PageBookmark"
              }
            ]
          }
        },
        "required": [
          "devices",
          "nextPageBookmark"
        ]
      },
      "DialectCreateResult": {
        "type": "object",
        "properties": {
          "dialectId": {
            "$ref": "#/components/schemas/DialectId"
          },
          "issues": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": []
          }
        },
        "required": [
          "dialectId"
        ]
      },
      "DialectId": {
        "type": "string"
      },
      "DirectGroup": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "DeviceDirectGroup": {
                "$ref": "#/components/schemas/DeviceDirectGroup"
              }
            },
            "required": [
              "DeviceDirectGroup"
            ]
          },
          {
            "type": "object",
            "properties": {
              "RawDirectGroup": {
                "$ref": "#/components/schemas/RawDirectGroup"
              }
            },
            "required": [
              "RawDirectGroup"
            ]
          }
        ]
      },
      "DomainDTO": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DomainId"
          },
          "description": {
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "id",
          "description"
        ]
      },
      "DomainId": {
        "type": "string"
      },
      "DomainQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "DomainWithPropertiesDTO": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DomainId"
          },
          "description": {
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "id",
          "description"
        ]
      },
      "EndpointName": {
        "type": "string"
      },
      "ErrorMessageWithOptCode": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "code": {
            "type": "integer",
            "format": "int32"
          }
        },
        "required": [
          "message"
        ]
      },
      "EventFilter": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/telemetry"
          },
          {
            "$ref": "#/components/schemas/lifecycle"
          }
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "telemetry": "#/components/schemas/telemetry",
            "lifecycle": "#/components/schemas/lifecycle"
          }
        }
      },
      "ExecuteArgumentList": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/executeArgument"
        }
      },
      "ExportToHyperscalerRequestBody": {
        "type": "object",
        "properties": {
          "groupId": {
            "type": "string"
          },
          "excludeIntegrated": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "groupId"
        ]
      },
      "ExternalId": {
        "type": "string"
      },
      "ExternalLocation": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string"
          },
          "username": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "password": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "fileUrl"
        ]
      },
      "FileResource": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "location": {
            "$ref": "#/components/schemas/Location"
          },
          "category": {
            "type": "string",
            "enum": [
              "FIRMWARE",
              "SOFTWARE",
              "UNKNOWN",
              "IMAGE"
            ]
          },
          "device": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DeviceId"
              }
            ],
            "default": null
          },
          "domain": {
            "type": "string"
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "directGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DirectGroup"
            },
            "uniqueItems": true,
            "default": []
          },
          "expirationTime": {
            "type": "string",
            "enum": [
              "ONE_DAY",
              "ONE_WEEK",
              "ONE_MONTH",
              "FOREVER"
            ]
          },
          "visibleForSubtenants": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "name",
          "location",
          "category",
          "domain",
          "expirationTime"
        ]
      },
      "FileResourceAddResult": {
        "type": "object",
        "properties": {
          "resourceId": {
            "$ref": "#/components/schemas/FileResourceId"
          },
          "staticPath": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "resourceId"
        ]
      },
      "FileResourceId": {
        "type": "string"
      },
      "FirmwareUpdateComponentResource": {
        "type": "object",
        "properties": {
          "resourceId": {
            "$ref": "#/components/schemas/FileResourceId"
          },
          "componentInstanceId": {
            "$ref": "#/components/schemas/ComponentInstanceId"
          }
        },
        "required": [
          "resourceId",
          "componentInstanceId"
        ],
        "example": {"resourceId":"123","componentInstanceId":0}
      },
      "FirmwareUpdateConfiguration": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/FirmwareUpdateConfigurationId"
          },
          "name": {
            "type": "string"
          },
          "notes": {
            "type": "string"
          },
          "domainId": {
            "$ref": "#/components/schemas/DomainId"
          },
          "visibleInSubDomains": {
            "type": "boolean"
          },
          "execution": {
            "$ref": "#/components/schemas/FirmwareUpdateExecutionConfiguration"
          },
          "expirationTimestamp": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "id",
          "name",
          "domainId",
          "visibleInSubDomains",
          "execution"
        ],
        "example": {"id":"64e74b62af83880a8493eb5c","name":"testName","notes":"Example notes","domainId":"/","visibleInSubDomains":true,"execution":{"kind":"Basic","resourceId":"123","transfer":{"deliveryMethod":"Pull","protocol":"HTTPS","uriFormat":"DNS"},"timeout":"10m"},"expirationTimestamp":"2023-09-20T14:54:20.577Z"}
      },
      "FirmwareUpdateConfigurationCreate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "notes": {
            "type": "string"
          },
          "visibleInSubDomains": {
            "type": "boolean",
            "default": true
          },
          "execution": {
            "$ref": "#/components/schemas/FirmwareUpdateExecutionConfiguration"
          }
        },
        "required": [
          "name",
          "execution"
        ],
        "example": {"name":"Example name","notes":"Example notes","visibleInSubDomains":true,"execution":{"kind":"Basic","resourceId":"123","transfer":{"deliveryMethod":"Pull","protocol":"HTTPS","uriFormat":"DNS"},"timeout":"10m"}}
      },
      "FirmwareUpdateConfigurationId": {
        "type": "string"
      },
      "FirmwareUpdateExecutionConfiguration": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Basic"
          },
          {
            "$ref": "#/components/schemas/Multicomponent"
          }
        ],
        "discriminator": {
          "propertyName": "kind",
          "mapping": {
            "Basic": "#/components/schemas/Basic",
            "Multicomponent": "#/components/schemas/Multicomponent"
          }
        },
        "example": {"kind":"Basic","resourceId":"123","transfer":{"deliveryMethod":"Pull","protocol":"HTTPS","uriFormat":"DNS"},"timeout":"10m"}
      },
      "FirmwareUpdateTransferConfiguration": {
        "type": "object",
        "description": "Usually `Pull` delivery method is recommended. `Push` might perform better for small firmware files.\nMeaning of 'small' depends on the network quality and devices capabilities.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Pull"
          },
          {
            "$ref": "#/components/schemas/Push"
          }
        ],
        "discriminator": {
          "propertyName": "deliveryMethod",
          "mapping": {
            "Pull": "#/components/schemas/Pull",
            "Push": "#/components/schemas/Push"
          }
        },
        "example": {"deliveryMethod":"Pull","protocol":"HTTPS","uriFormat":"DNS"}
      },
      "FirmwareUpdateUriFormat": {
        "type": "string",
        "enum": [
          "RawIP",
          "DNS"
        ]
      },
      "FormattedPsk": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "HexadecimalPsk": {
                "$ref": "#/components/schemas/HexadecimalPsk"
              }
            },
            "required": [
              "HexadecimalPsk"
            ]
          },
          {
            "type": "object",
            "properties": {
              "PlainTextPsk": {
                "$ref": "#/components/schemas/PlainTextPsk"
              }
            },
            "required": [
              "PlainTextPsk"
            ]
          },
          {
            "type": "object",
            "properties": {
              "BinaryPsk": {
                "$ref": "#/components/schemas/BinaryPsk"
              }
            },
            "required": [
              "BinaryPsk"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ExternalPsk": {
                "type": "object"
              }
            },
            "required": [
              "ExternalPsk"
            ]
          },
          {
            "type": "object",
            "properties": {
              "GlobalPsk": {
                "type": "object"
              }
            },
            "required": [
              "GlobalPsk"
            ]
          }
        ]
      },
      "GroupDTO": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/GroupId"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "id"
        ]
      },
      "GroupId": {
        "type": "string"
      },
      "GroupObservationRequest": {
        "type": "object",
        "properties": {
          "minPeriod": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "default": null
          },
          "maxPeriod": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "default": null
          },
          "createEnsureObserveIfNotExists": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "GroupQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "HandlerId": {
        "type": "string"
      },
      "HandlerTestResponse": {
        "type": "object",
        "properties": {
          "successful": {
            "type": "boolean"
          },
          "message": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "successful"
        ]
      },
      "HexadecimalPsk": {
        "type": "string"
      },
      "IamUserDto": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "emailVerified": {
            "type": "boolean"
          },
          "domain": {
            "$ref": "#/components/schemas/DomainId"
          },
          "password": {
            "type": "string"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "tosAccepted": {
            "type": "boolean"
          }
        },
        "required": [
          "login",
          "email",
          "emailVerified",
          "domain",
          "password",
          "roles",
          "permissions",
          "tosAccepted"
        ]
      },
      "IamUserPatchDto": {
        "type": "object",
        "properties": {
          "emailVerified": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "userEnabled": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "domain": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DomainId"
              }
            ],
            "default": null
          },
          "password": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "roles": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": null
          },
          "permissions": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": null
          },
          "tosAccepted": {
            "type": "boolean",
            "nullable": true,
            "default": null
          }
        }
      },
      "Instantiation": {
        "type": "object",
        "properties": {
          "resourceInstanceId": {
            "type": "integer",
            "format": "int32"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "resourceInstanceId",
          "value"
        ]
      },
      "InternalLocation": {
        "type": "object",
        "properties": {
          "fileName": {
            "type": "string"
          },
          "staticContent": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "fileName"
        ]
      },
      "JobId": {
        "type": "string"
      },
      "KafkaConnectionConfig": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/domainProperty"
          },
          {
            "$ref": "#/components/schemas/custom"
          }
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "domainProperty": "#/components/schemas/domainProperty",
            "custom": "#/components/schemas/custom"
          }
        }
      },
      "LnsServerUrl": {
        "type": "string"
      },
      "Location": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "InternalLocation": {
                "$ref": "#/components/schemas/InternalLocation"
              }
            },
            "required": [
              "InternalLocation"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ExternalLocation": {
                "$ref": "#/components/schemas/ExternalLocation"
              }
            },
            "required": [
              "ExternalLocation"
            ]
          }
        ]
      },
      "LoraGatewayDTO": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "endpointName": {
            "$ref": "#/components/schemas/EndpointName"
          },
          "hasEui": {
            "type": "boolean"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "frequencyPlan": {
            "type": "string"
          },
          "antennaGain": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "default": null
          },
          "lwm2m": {
            "$ref": "#/components/schemas/LwM2MSettings"
          }
        },
        "required": [
          "id",
          "endpointName",
          "hasEui",
          "frequencyPlan",
          "lwm2m"
        ]
      },
      "LwM2MSettings": {
        "type": "object",
        "properties": {
          "securityMode": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityMode"
              }
            ],
            "default": null
          },
          "dtlsIdentity": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "dtlsPsk": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/FormattedPsk"
              }
            ],
            "default": null
          },
          "bootstrapSupported": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "Lwm2mPath": {
        "type": "string"
      },
      "Lwm2mUrl": {
        "type": "string"
      },
      "Lwm2mUrlAlias": {
        "type": "string"
      },
      "MonitoredResourceConfiguration": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string"
          },
          "resourceType": {
            "type": "string",
            "enum": [
              "Textual",
              "Numerical"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResourceSource"
          },
          "storeSamples": {
            "type": "boolean"
          },
          "storeAggregates": {
            "type": "boolean"
          },
          "isPassive": {
            "type": "boolean"
          }
        },
        "required": [
          "displayName",
          "resourceType",
          "source",
          "storeSamples",
          "storeAggregates",
          "isPassive"
        ]
      },
      "MonitoringConfigurationDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "targetGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupId"
            },
            "uniqueItems": true
          },
          "resourcesConfigurations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitoredResourceConfiguration"
            }
          },
          "samplingIntervalSeconds": {
            "type": "integer",
            "format": "int32",
            "default": 60
          },
          "description": {
            "type": "string",
            "default": ""
          },
          "isActive": {
            "type": "boolean",
            "default": true
          },
          "runCondition": {
            "type": "string",
            "default": ""
          },
          "excludeGroupsRegexPatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          }
        },
        "required": [
          "name",
          "targetGroups",
          "resourcesConfigurations"
        ]
      },
      "MonitoringConfigurationQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** ([string]) : contains, notcontains, containsany\n- **samplingInterval** (integer($int32)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **active** (boolean) : eq\n- **description** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **condition** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "MonitoringConfigurationUpdate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "samplingIntervalSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "default": null
          },
          "addTargetGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupId"
            },
            "uniqueItems": true,
            "default": []
          },
          "removeTargetGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupId"
            },
            "uniqueItems": true,
            "default": []
          },
          "removeResourcesConfigurations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          },
          "addResourcesConfigurations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitoredResourceConfiguration"
            },
            "default": []
          },
          "description": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "runCondition": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "addExcludedGroupsPatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          },
          "removeExcludedGroupsPatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "default": []
          }
        }
      },
      "MonitoringDataResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceMonitoringData"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "hasNext": {
            "type": "boolean"
          },
          "lastPointTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "required": [
          "data",
          "hasNext",
          "lastPointTimestamp"
        ]
      },
      "MonitoringEnabledResponse": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "MonitoringSample": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "numericResources": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "double",
              "nullable": true
            }
          },
          "textualResources": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "date",
          "numericResources",
          "textualResources"
        ]
      },
      "Multicomponent": {
        "type": "object",
        "description": "`Multicomponent` configuration kind is a firmware update implementation specific to AVSystem Anjay LwM2M client.",
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "Multicomponent"
            ]
          },
          "componentResources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FirmwareUpdateComponentResource"
            }
          },
          "transfer": {
            "$ref": "#/components/schemas/FirmwareUpdateTransferConfiguration"
          },
          "timeout": {
            "$ref": "#/components/schemas/TimeSpan"
          }
        },
        "required": [
          "kind",
          "componentResources",
          "transfer",
          "timeout"
        ]
      },
      "Multiple": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Instantiation"
            }
          }
        },
        "required": [
          "values"
        ]
      },
      "Notification": {
        "type": "object",
        "properties": {
          "deviceId": {
            "$ref": "#/components/schemas/DeviceId"
          },
          "observedPath": {
            "$ref": "#/components/schemas/Lwm2mPath"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathValue"
            }
          }
        },
        "required": [
          "deviceId",
          "observedPath",
          "timestamp",
          "values"
        ]
      },
      "NumericalAggregate": {
        "type": "object",
        "properties": {
          "bucketStart": {
            "type": "string",
            "format": "date-time"
          },
          "bucketEnd": {
            "type": "string",
            "format": "date-time"
          },
          "sum": {
            "type": "number",
            "format": "double"
          },
          "sqrSum": {
            "type": "number",
            "format": "double"
          },
          "count": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "bucketStart",
          "bucketEnd",
          "sum",
          "sqrSum",
          "count"
        ]
      },
      "ObjectDefinition": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string"
          },
          "objectVersion": {
            "type": "string"
          },
          "instanceType": {
            "type": "string",
            "enum": [
              "Single",
              "Multiple"
            ]
          },
          "mandatory": {
            "type": "boolean"
          },
          "description": {
            "type": "string"
          },
          "resourceDefinitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceDefinition"
            }
          }
        },
        "required": [
          "id",
          "name",
          "objectVersion",
          "instanceType",
          "mandatory",
          "description",
          "resourceDefinitions"
        ]
      },
      "ObservationAttribute": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "ObservationData": {
        "type": "object",
        "properties": {
          "deviceId": {
            "$ref": "#/components/schemas/DeviceId"
          },
          "path": {
            "$ref": "#/components/schemas/Lwm2mPath"
          },
          "attributes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObservationAttribute"
            }
          }
        },
        "required": [
          "deviceId",
          "path",
          "attributes"
        ]
      },
      "ObservationId": {
        "type": "object",
        "properties": {
          "targetEntity": {
            "$ref": "#/components/schemas/TargetEntity"
          },
          "path": {
            "$ref": "#/components/schemas/Lwm2mPath"
          }
        },
        "required": [
          "targetEntity",
          "path"
        ]
      },
      "ObservationQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **device** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **path** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "ObservationRequest": {
        "type": "object",
        "properties": {
          "attributes": {
            "$ref": "#/components/schemas/AttributesVector"
          },
          "createEnsureObserveIfNotExists": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "attributes"
        ]
      },
      "OmaXmlObjectDefinition": {
        "type": "string",
        "description": "Specification of an LwM2M object",
        "externalDocs": {
          "url": "http://www.openmobilealliance.org/tech/profiles/LWM2M.xsd",
          "description": "Official specification"
        }
      },
      "PageBookmark": {
        "type": "string"
      },
      "PathValue": {
        "type": "object",
        "properties": {
          "path": {
            "$ref": "#/components/schemas/Lwm2mPath"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "path",
          "value"
        ]
      },
      "PlainTextPsk": {
        "type": "string"
      },
      "Pull": {
        "type": "object",
        "description": "When using `Pull` delivery method, the device will download firmware on its own.",
        "properties": {
          "deliveryMethod": {
            "type": "string",
            "enum": [
              "Pull"
            ]
          },
          "protocol": {
            "$ref": "#/components/schemas/TransferProtocol"
          },
          "uriFormat": {
            "$ref": "#/components/schemas/FirmwareUpdateUriFormat"
          }
        },
        "required": [
          "deliveryMethod",
          "protocol",
          "uriFormat"
        ]
      },
      "Push": {
        "type": "object",
        "description": "When using `Push` delivery method, the firmware will be sent as inbound CoAP block message.",
        "properties": {
          "deliveryMethod": {
            "type": "string",
            "enum": [
              "Push"
            ]
          }
        },
        "required": [
          "deliveryMethod"
        ]
      },
      "RawDirectGroup": {
        "type": "string"
      },
      "ResourceDefinition": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string"
          },
          "operations": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "Read",
                "Write",
                "Execute"
              ]
            }
          },
          "instanceType": {
            "type": "string",
            "enum": [
              "Single",
              "Multiple"
            ]
          },
          "mandatory": {
            "type": "boolean"
          },
          "type": {
            "type": "string",
            "enum": [
              "String",
              "Integer",
              "UnsignedInteger",
              "Float",
              "Boolean",
              "Opaque",
              "Time",
              "Objlnk",
              "Corelnk",
              "None"
            ]
          },
          "range": {
            "type": "string"
          },
          "units": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "operations",
          "instanceType",
          "mandatory",
          "type",
          "range",
          "units",
          "description"
        ]
      },
      "ResourceDownloadData": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "required": [
          "address"
        ]
      },
      "ResourceInstanceData": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/Value"
          },
          "resourceId": {
            "type": "integer",
            "format": "int32"
          },
          "operations": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "Read",
                "Write",
                "Execute"
              ]
            }
          },
          "instanceType": {
            "type": "string",
            "enum": [
              "Single",
              "Multiple"
            ]
          },
          "mandatory": {
            "type": "boolean"
          },
          "type": {
            "type": "string",
            "enum": [
              "String",
              "Integer",
              "UnsignedInteger",
              "Float",
              "Boolean",
              "Opaque",
              "Time",
              "Objlnk",
              "Corelnk",
              "None"
            ]
          },
          "range": {
            "type": "string"
          },
          "units": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "path",
          "value",
          "resourceId",
          "operations",
          "instanceType",
          "mandatory",
          "type",
          "range",
          "units",
          "description"
        ]
      },
      "ResourceMonitoringData": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "date",
          "value"
        ]
      },
      "ResourceSource": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "DataModelSource": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string"
                  }
                },
                "required": [
                  "key"
                ]
              }
            },
            "required": [
              "DataModelSource"
            ]
          },
          {
            "type": "object",
            "properties": {
              "SettingValueSource": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ]
              }
            },
            "required": [
              "SettingValueSource"
            ]
          }
        ]
      },
      "SampleBatch": {
        "type": "object",
        "properties": {
          "batch": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitoringSample"
            }
          },
          "nextCursor": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/SampleCursor"
              }
            ]
          }
        },
        "required": [
          "batch",
          "nextCursor"
        ]
      },
      "SampleCursor": {
        "type": "integer",
        "format": "int64"
      },
      "SecurityMode": {
        "type": "string",
        "enum": [
          "psk",
          "cert",
          "rpk",
          "nosec",
          "unknown",
          "notset"
        ]
      },
      "SettingValueDTO": {
        "type": "object",
        "properties": {
          "groupId": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupId"
              }
            ],
            "default": null
          },
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "isSecret": {
            "type": "boolean",
            "default": false
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "SettingValueQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **groupId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **value** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "Single": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string"
          }
        },
        "required": [
          "value"
        ]
      },
      "Successful": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string"
          }
        },
        "required": [
          "result"
        ]
      },
      "SuccessfulMessage": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          }
        },
        "required": [
          "message"
        ]
      },
      "SuccessfulWithId": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "default": "Success"
          },
          "id": {
            "type": "string"
          }
        },
        "required": [
          "id"
        ]
      },
      "TargetEntity": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "DeviceId": {
                "$ref": "#/components/schemas/DeviceId"
              }
            },
            "required": [
              "DeviceId"
            ]
          },
          {
            "type": "object",
            "properties": {
              "GroupId": {
                "$ref": "#/components/schemas/GroupId"
              }
            },
            "required": [
              "GroupId"
            ]
          }
        ]
      },
      "TaskCallback": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "uri",
          "name"
        ]
      },
      "TaskConfig": {
        "type": "object",
        "properties": {
          "taskName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskParameter"
            },
            "default": []
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "default": null
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          }
        }
      },
      "TaskDTO": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/TaskId"
          },
          "config": {
            "$ref": "#/components/schemas/TaskConfig"
          }
        },
        "required": [
          "id",
          "config"
        ]
      },
      "TaskId": {
        "type": "string"
      },
      "TaskParameter": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "TaskQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **id** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **group** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **device** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **name** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **creationTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **active** (boolean) : eq\n- **properties.&ast;** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "TaskReportBatch": {
        "type": "object",
        "properties": {
          "batch": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskReportDTO"
            }
          },
          "nextCursor": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskReportCursor"
              }
            ]
          }
        },
        "required": [
          "batch",
          "nextCursor"
        ]
      },
      "TaskReportCursor": {
        "type": "integer",
        "format": "int64"
      },
      "TaskReportDTO": {
        "type": "object",
        "properties": {
          "taskId": {
            "$ref": "#/components/schemas/TaskId"
          },
          "deviceId": {
            "$ref": "#/components/schemas/DeviceId"
          },
          "startTime": {
            "type": "string",
            "format": "date-time"
          },
          "finishTime": {
            "type": "string",
            "format": "date-time"
          },
          "lastUpdateTime": {
            "type": "string",
            "format": "date-time"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "summary": {
            "type": "string"
          },
          "blocking": {
            "type": "boolean"
          },
          "properties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskParameter"
            }
          }
        },
        "required": [
          "taskId",
          "deviceId",
          "startTime",
          "finishTime",
          "lastUpdateTime",
          "status",
          "summary",
          "blocking",
          "properties"
        ]
      },
      "TaskReportId": {
        "type": "object",
        "properties": {
          "taskId": {
            "$ref": "#/components/schemas/TaskId"
          },
          "deviceId": {
            "$ref": "#/components/schemas/DeviceId"
          }
        },
        "required": [
          "taskId",
          "deviceId"
        ]
      },
      "TaskReportQuery": {
        "type": "string",
        "format": "csv",
        "description": "\n Comma-separated list of conditions.\n\n Conditions are concatenated internally using *AND* logical operator. <br />\n Condition has the following form: '*fieldName operator value*' or '*fieldName operator*'\n ## Available fields and operators:\n - **taskId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **deviceId** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n- **startTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **finishTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **lastUpdateTime** (string($date-time)) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte\n- **status** (#/components/schemas/TaskStatus) : eq, ne, in, nin, exists, notexists\n- **summary** (string) : eq, ne, in, nin, exists, notexists, gt, gte, lt, lte, strcontains, matches, startswith, endswith\n\n ## Value types:\n - *string* - surround with single quotes: '. Escape single quotes in queries with another single quote: ''. E.g. 'Cite: ''cited text''.'.\n - *boolean* - true or false\n - *string($date-time)* - string in the ISO8601 format\n - *string($byte)* - base64 encoded string\n - *numeric* - for example: 0.123, 123, 12.123\n - *[Value type]* - array of value types. Array has the form of: [item1, item2, ...]\n - *object* - JSON object wrapped in backtick: \\`. Escape backtick inside JSON string with another backtick: \\`\\`. E.g. \\`{\"backtick\": \"\\`\\`\"}\\`\n\n ## Operators:\n - **eq** - Field value is equal to condition value. Condition Value Type = Field Type\n- **ne** - Field value is different than condition value. Condition Value Type = Field Type\n- **in** - Field value is equal to one of the given values. Condition Value Type = [Field Type]\n- **nin** - Field value is different than all given values. Condition Value Type = [Field Type]\n- **gt** - Field value is greater than given value. Condition Value Type = Field Type\n- **gte** - Field value is greater or equal to given value. Condition Value Type = Field Type\n- **lt** - Field value is lower than given value. Condition Value Type = Field Type\n- **lte** - Field value is lower or equal to given value. Condition Value Type = Field Type\n- **contains** - Field value contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **notcontains** - Field value not contains the given value. Applicable only to collection fields. Condition Value Type = Field Item Type\n- **containsany** - Field value contains any of the given values. Applicable only to collection fields. Condition Value Type = Field Type\n- **strcontains** - Field value contains given substring. Applicable only to string fields. Condition Value Type = string\n- **matches** - Field value matches given regular expression. Applicable only to string fields. Condition Value Type = string\n- **startswith** - Field value starts with given string. Applicable only to string fields. Condition Value Type = string\n- **endswith** - Field value ends with given string. Applicable only to string fields. Condition Value Type = string\n- **exists** - Field has any value.\n- **notexists** - Field doesn't have any value.\n\n ## Examples:\n - *someStringField eq 'string'*\n - *someDateCollection containsany ['2012-09-01T08:51:23.180Z', '2012-09-02T08:51:23.180Z']*\n - *someMapField.keyName eq 'value'*\n - *someBooleanField eq true*\n - *someField exists*\n - *someStringField eq 'string'***,** *someField exists*\n\n\n      "
      },
      "TaskReportsSummary": {
        "type": "object",
        "properties": {
          "totalScheduled": {
            "type": "integer",
            "format": "int64"
          },
          "inProgress": {
            "type": "integer",
            "format": "int64"
          },
          "completed": {
            "type": "integer",
            "format": "int64"
          },
          "successes": {
            "type": "integer",
            "format": "int64"
          },
          "failures": {
            "type": "integer",
            "format": "int64"
          },
          "notCompleted": {
            "type": "integer",
            "format": "int64"
          },
          "completionRate": {
            "type": "number",
            "format": "float"
          },
          "successRate": {
            "type": "number",
            "format": "float"
          },
          "failureRate": {
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "totalScheduled",
          "inProgress",
          "completed",
          "successes",
          "failures",
          "notCompleted",
          "completionRate",
          "successRate",
          "failureRate"
        ]
      },
      "TaskStatus": {
        "type": "string",
        "enum": [
          "InProgress",
          "Success",
          "Warning",
          "Error",
          "NotStarted"
        ]
      },
      "TaskTemplateInvocation": {
        "type": "object",
        "properties": {
          "templateName": {
            "type": "string"
          },
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskConfig"
              }
            ],
            "default": {"taskName":null,"parameters":[],"isActive":null,"properties":{}}
          },
          "callback": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskCallback"
              }
            ],
            "default": null
          }
        },
        "required": [
          "templateName"
        ]
      },
      "TestExecutionReport": {
        "type": "object",
        "properties": {
          "passedSuccessfully": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "waitingForExecution": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "passedWithWarning": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "failed": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "passedSuccessfully",
          "waitingForExecution",
          "passedWithWarning",
          "failed"
        ]
      },
      "TextualAggregate": {
        "type": "object",
        "properties": {
          "bucketStart": {
            "type": "string",
            "format": "date-time"
          },
          "bucketEnd": {
            "type": "string",
            "format": "date-time"
          },
          "values": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          }
        },
        "required": [
          "bucketStart",
          "bucketEnd",
          "values"
        ]
      },
      "TheThingsStackIntegrationCreationDTO": {
        "type": "object",
        "properties": {
          "consoleServerUrl": {
            "$ref": "#/components/schemas/ConsoleServerUrl"
          },
          "lnsServerUrl": {
            "$ref": "#/components/schemas/LnsServerUrl"
          },
          "username": {
            "$ref": "#/components/schemas/TheThingsStackUsername"
          },
          "personalApiKey": {
            "$ref": "#/components/schemas/TheThingsStackPersonalApiKey"
          }
        },
        "required": [
          "consoleServerUrl",
          "lnsServerUrl",
          "username",
          "personalApiKey"
        ]
      },
      "TheThingsStackIntegrationInformationDTO": {
        "type": "object",
        "properties": {
          "consoleServerUrl": {
            "$ref": "#/components/schemas/ConsoleServerUrl"
          },
          "lnsServerUrl": {
            "$ref": "#/components/schemas/LnsServerUrl"
          },
          "username": {
            "$ref": "#/components/schemas/TheThingsStackUsername"
          }
        },
        "required": [
          "consoleServerUrl",
          "lnsServerUrl",
          "username"
        ]
      },
      "TheThingsStackPersonalApiKey": {
        "type": "string"
      },
      "TheThingsStackUsername": {
        "type": "string"
      },
      "TimeSpan": {
        "type": "string",
        "description": "Time with unit or number of seconds: e.g (`1h 20m`, `300s` or `30`)."
      },
      "TransferMode": {
        "type": "string",
        "enum": [
          "Push",
          "Pull"
        ]
      },
      "TransferProtocol": {
        "type": "string",
        "description": "Protocol used for downloading firmware file. Some devices might not support all possible protocols.\nTo find out which protocols are supported by the device please check the value of the Firmware Update\nProtocol Support resource in the Firmware Update LwM2M object.\n",
        "enum": [
          "HTTP",
          "HTTPS",
          "COAP",
          "COAPS",
          "COAP_TCP",
          "COAP_TLS"
        ]
      },
      "UpgradeStrategy": {
        "type": "string",
        "enum": [
          "ObservationTrigger",
          "WithoutObservations",
          "ObservationBased",
          "SendBased"
        ]
      },
      "UserAuthCertRequest": {
        "type": "object",
        "properties": {
          "certificatePem": {
            "type": "string"
          }
        },
        "required": [
          "certificatePem"
        ]
      },
      "UserDto": {
        "type": "object",
        "properties": {
          "userId": {
            "$ref": "#/components/schemas/UserId"
          },
          "login": {
            "type": "string"
          },
          "active": {
            "type": "boolean"
          },
          "superUser": {
            "type": "boolean"
          },
          "staff": {
            "type": "boolean"
          },
          "domain": {
            "$ref": "#/components/schemas/DomainId"
          },
          "password": {
            "type": "string"
          },
          "accessSchedule": {
            "type": "string"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time"
          },
          "creationDate": {
            "type": "string",
            "format": "date-time"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "fullName": {
            "type": "string",
            "nullable": true,
            "default": null
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          }
        },
        "required": [
          "userId",
          "login",
          "active",
          "superUser",
          "staff",
          "domain",
          "password",
          "accessSchedule",
          "expirationDate",
          "creationDate",
          "roles",
          "permissions"
        ]
      },
      "UserId": {
        "type": "string"
      },
      "Value": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "Single": {
                "$ref": "#/components/schemas/Single"
              }
            },
            "required": [
              "Single"
            ]
          },
          {
            "type": "object",
            "properties": {
              "Multiple": {
                "$ref": "#/components/schemas/Multiple"
              }
            },
            "required": [
              "Multiple"
            ]
          }
        ]
      },
      "WebhookAuthMethod": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/taggedbasic"
          },
          {
            "$ref": "#/components/schemas/taggedtoken"
          }
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "basic": "#/components/schemas/taggedbasic",
            "token": "#/components/schemas/taggedtoken"
          }
        }
      },
      "WebhookConnectionConfig": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string"
          },
          "auth": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/WebhookAuthMethod"
              }
            ],
            "default": null
          },
          "additionalHeaders": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          },
          "format": {
            "type": "string",
            "enum": [
              "generic",
              "influxDb"
            ],
            "default": "generic"
          },
          "method": {
            "type": "string",
            "enum": [
              "post",
              "patch",
              "put"
            ],
            "default": "post"
          }
        },
        "required": [
          "uri"
        ]
      },
      "basic": {
        "type": "object",
        "properties": {
          "user": {
            "type": "string"
          },
          "password": {
            "type": "string"
          }
        },
        "required": [
          "user",
          "password"
        ]
      },
      "custom": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "custom"
            ]
          },
          "value": {
            "type": "string"
          },
          "topic": {
            "type": "string"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          }
        },
        "required": [
          "type",
          "value",
          "topic"
        ]
      },
      "domainProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "domainProperty"
            ]
          },
          "topic": {
            "type": "string"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "default": {}
          }
        },
        "required": [
          "type",
          "topic"
        ]
      },
      "executeArgument": {
        "type": "object",
        "properties": {
          "digit": {
            "type": "string",
            "maxLength": 1,
            "minLength": 1
          },
          "argument": {
            "type": "string",
            "nullable": true,
            "default": null
          }
        },
        "required": [
          "digit"
        ]
      },
      "kafka": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/HandlerId"
          },
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "domain": {
            "$ref": "#/components/schemas/DomainId"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/KafkaConnectionConfig"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "enabled",
          "domain",
          "connectionConfig",
          "filter"
        ]
      },
      "lifecycle": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "lifecycle"
            ]
          },
          "eventTypes": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "deviceCreated",
                "deviceFirstRegistration",
                "deviceUpdatedViaWrite",
                "deviceUpdatedViaFota",
                "deviceDeleted"
              ]
            },
            "uniqueItems": true
          }
        },
        "required": [
          "type",
          "eventTypes"
        ]
      },
      "taggedbasic": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "basic"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "$ref": "#/components/schemas/basic"
          }
        ]
      },
      "taggedkafka": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kafka"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "$ref": "#/components/schemas/kafka"
          }
        ]
      },
      "taggedtoken": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "token"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "$ref": "#/components/schemas/token"
          }
        ]
      },
      "taggedwebhook": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "webhook"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "$ref": "#/components/schemas/webhook"
          }
        ]
      },
      "telemetry": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "telemetry"
            ]
          },
          "lwm2mUrls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Lwm2mUrl"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "type",
          "lwm2mUrls"
        ]
      },
      "token": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        },
        "required": [
          "token"
        ]
      },
      "webhook": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/HandlerId"
          },
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "domain": {
            "$ref": "#/components/schemas/DomainId"
          },
          "connectionConfig": {
            "$ref": "#/components/schemas/WebhookConnectionConfig"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "enabled",
          "domain",
          "connectionConfig",
          "filter"
        ]
      }
    },
    "securitySchemes": {
      "auth": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "https://eu.iot.avsystem.cloud/api/auth/oauth_password"
          }
        }
      }
    }
  },
  "security": [
    {
      "auth": []
    }
  ],
  "tags": [
    {
      "name": "Devices",
      "description": "Create, delete, or update devices. Retrieve device information."
    },
    {
      "name": "Groups",
      "description": "Create, update, retrieve, and delete groups of devices."
    },
    {
      "name": "Tasks",
      "description": "Create device configuration or firmware update task. Update, retrieve and delete tasks."
    },
    {
      "name": "TasksFromTemplates",
      "description": "Create tasks that will be executed on a device or a group using task templates. Create a device-blocking task."
    },
    {
      "name": "TaskReports",
      "description": "Get reports, report summaries, and report batches using search criteria. Get reports for a specific task and device."
    },
    {
      "name": "SettingValues",
      "description": "Create, update, and retrieve setting values for a device or group."
    },
    {
      "name": "CachedDataModels",
      "description": "Get device data model parameters."
    },
    {
      "name": "LegacyMonitoringData",
      "description": "Endpoints for a depreciated monitoring system, that will be deleted in the future. Use DeviceMonitoring instead."
    },
    {
      "name": "LegacyMonitoringConfiguration",
      "description": "Endpoints for a depreciated monitoring system, that will be deleted in the future. Use DeviceMonitoring instead."
    },
    {
      "name": "Domains",
      "description": "Create, update, or delete domains. Retrieve data about existing domains."
    },
    {
      "name": "Users",
      "description": "Create, update, retrieve, and delete users."
    },
    {
      "name": "Sessions",
      "description": "Start the provisioning session with a registered or unregistered device."
    },
    {
      "name": "InstantiatedResources",
      "description": "Retrieve definitions and values of instantiated resources."
    },
    {
      "name": "Observations",
      "description": "Create, update, retrieve, and delete observations on devices."
    },
    {
      "name": "Resources",
      "description": "Create and update resource instances. Obtain a secure download URL to an existing resource."
    },
    {
      "name": "Dialects",
      "description": "Add or update LwM2M object specification."
    },
    {
      "name": "AssignedDeviceProperties",
      "description": "Create, update, modify, retrieve, and delete assigned properties."
    },
    {
      "name": "Extensions",
      "description": "Manage Azure DPS, Azure IoT Central, Azure IoT Hub and The Things Stack LoRaWAN gateways extensions for your domain."
    },
    {
      "name": "DeviceTests",
      "description": "Schedule tests on devices and retrieve reports of executed tests."
    },
    {
      "name": "AwsIntegration",
      "description": "Save and delete the certificate used by AWS for integration with the platform."
    },
    {
      "name": "CertificatesAuth",
      "description": "Save and delete the certificate for validating incoming requests from AWS."
    },
    {
      "name": "DeviceMonitoring",
      "description": "Enable or disable monitoring on a device or group, and retrieve monitoring data from devices using aliases or LwM2M URLs."
    },
    {
      "name": "DeviceLifecycleManagement",
      "description": "Enable or disable the factory testing phase for a device."
    },
    {
      "name": "DeviceEventHandlers",
      "description": "Create and maintain event handlers used to send data outside the application (NBI)."
    },
    {
      "name": "Firmware Update Configuration",
      "description": "Create and manage firmware update configurations."
    }
  ]
}